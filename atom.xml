<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[WooLong's Notes]]></title>
  <subtitle><![CDATA[生命不息，奋斗不止]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-10-13T03:21:25.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[WooLong]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Git显示漂亮日志的小技巧]]></title>
    <link href="http://yoursite.com/2015/10/13/Git%E6%98%BE%E7%A4%BA%E6%BC%82%E4%BA%AE%E6%97%A5%E5%BF%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2015/10/13/Git显示漂亮日志的小技巧/</id>
    <published>2015-10-13T02:54:06.000Z</published>
    <updated>2015-10-13T03:21:25.000Z</updated>
    <content type="html"><![CDATA[<p>Git的传统log如下所示，你喜欢吗？</p>
<p><img src="/images/201510/git.log01.png" alt="git_log01"></p>
<p>看看下面这个你喜欢不喜欢？</p>
<p><img src="/images/201510/git.log02.png" alt="git_log2"></p>
<p>要做到这样，命令行如下：</p>
<pre><code>git <span class="keyword">log</span> --<span class="keyword">graph</span> --pretty=<span class="keyword">format</span>:'%Cred%<span class="keyword">h</span>%Creset -%C(yellow)%<span class="keyword">d</span>%Creset %s <span class="label">$Cgreen</span>(%cr) %C(bold blue)&lt;%<span class="keyword">an</span>&gt;%Creset' --abbrev-commit --
</code></pre><p>这样有点长了，我们可以这样：</p>
<pre><code>git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'<span class="variable">%Cred</span><span class="variable">%h</span><span class="variable">%Creset</span> -<span class="variable">%C</span>(yellow)<span class="variable">%d</span><span class="variable">%Creset</span> <span class="variable">%s</span> <span class="variable">%Cgreen</span>(<span class="variable">%cr</span>) <span class="variable">%C</span>(bold blue)&lt;<span class="variable">%an</span>&gt;<span class="variable">%Creset</span>' --abbrev-commit --"</span>
</code></pre><p>然后，我们以后就可以使用这样的短命令了：</p>
<pre><code><span class="title">git</span> lg
</code></pre><p>如果你想看看 git log -pretty=format 的参数，你可以看看<a href="http://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="external">这篇文章</a></p>
<blockquote>
<p>ps:来自 <a href="http://coolshell.cn/articles/7755.html" target="_blank" rel="external">http://coolshell.cn/articles/7755.html</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Git的传统log如下所示，你喜欢吗？</p>
<p><img src="/images/201510/git.log01.png" alt="git_log01"></p>
<p>看看下面这个你喜欢不喜欢？</p>
<p><img src="/images/201510/]]>
    </summary>
    
      <category term="［git,工具,log］" scheme="http://yoursite.com/tags/%EF%BC%BBgit-%E5%B7%A5%E5%85%B7-log%EF%BC%BD/"/>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySql性能优化的最佳20+条经验]]></title>
    <link href="http://yoursite.com/2015/10/10/MySql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B320-%E6%9D%A1%E7%BB%8F%E9%AA%8C/"/>
    <id>http://yoursite.com/2015/10/10/MySql性能优化的最佳20-条经验/</id>
    <published>2015-10-09T17:53:26.000Z</published>
    <updated>2015-10-13T03:24:43.000Z</updated>
    <content type="html"><![CDATA[<p>今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们不会讲过多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。</p>
<h3 id="1-_为查询缓存优化你的查询">1. 为查询缓存优化你的查询</h3><p>大多数的 MySQL 服务器都开启了查询缓存。这是提高性能最有效的方法之一，而且这是被 MySQL 的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。</p>
<p>这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让 MySQL 不使用缓存。请看下面的例子：</p>
<pre><code>// 不使用查询缓存
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT id FROM user WHERE dateline &gt;= CURDATE()"</span>);

// 使用查询缓存
<span class="variable">$time</span> = date(<span class="string">"Y-m-d"</span>);
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT id FROM user WHERE dateline &gt;= '$time'"</span>);
</code></pre><h3 id="2-_EXPLAIN_你的_SELECT_查询">2. EXPLAIN 你的 SELECT 查询</h3><p>使用 <a href="http://dev.mysql.com/doc/refman/5.0/en/explain.html" target="_blank" rel="external">EXPLAIN</a> 关键字可以让你知道 MySQL 是如何处理你的 SQL 语句的。这可以帮你i分析你的查询语句或是表结构的性能瓶颈。</p>
<p>EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的…等等。</p>
<p>挑一个你的 SELECT 语句（推荐选最复杂的，有多表连接的），把关键字 EXPLAIN 加到前面。你可以使用 phpmyadmin 来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了 group_id 索引，并且有表连接：</p>
<p><img src="/images/201509/unoptimized_explain.jpg" alt="explain"></p>
<p>当我们为 group_id 字段加上索引后：</p>
<p><img src="/images/201509/optimized_explain.jpg" alt="explain"></p>
<p>我们可以看到，前一个结果显示了 7883 行，而后一个只是搜索了两个表的 9 和 16 行。查看 rows 列可以让我们找到潜在的性能问题。</p>
<h3 id="3-_当只要一行数据时使用_LIMIT_1">3. 当只要一行数据时使用 LIMIT 1</h3><p>当你查询表的时候，你已经知道结果智慧有一条结果，但因为你可能需要去 fetch 游标，或是你也许会去检查返回的记录数。</p>
<p>在这种情况下，加上 LIMIT 1 可以增加性能。这样 MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查下一条符合记录的数据。</p>
<p>下面的示例只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是 SELECT *，第二条是 SELECT 1）</p>
<pre><code>// 没有效率的：
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT * FROM user WHERE country = 'China'"</span>);
<span class="keyword">if</span> (mysql_num_rows(<span class="variable">$r</span>) &gt; <span class="number">0</span>) {
    // ...
}

// 有效率的：
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT 1 FROM user WHERE country = 'China' LIMIT 1"</span>);
<span class="keyword">if</span> (mysql_num_rows(<span class="variable">$r</span>) &gt; <span class="number">0</span>) {
    // ...
}
</code></pre><h3 id="4-_为搜索字段建索引">4. 为搜索字段建索引</h3><p>索引并不一定就是给主键或是唯一的字段。如果在你的表中有某个字段你总经常用来做搜索，那么请为它建立索引吧。</p>
<p><img src="/images/201509/search_index.jpg" alt="search"></p>
<p>从上图你可以看到那个搜索字串 “last_name_LIKE ‘a%’”，一个是建了索引，一个是没有建索引，性能差了 4 倍左右。</p>
<p>另外，你应该也知道什么样的搜索是不能使用正常索引的。例如，当你需要在一篇大的文章中搜索一个词时，如：“WHERE post_content LIKE ‘%apple%’”，索引可能是没有意义的。你可能需要使用 <a href="http://dev.mysql.com/doc/refman/5.1/en/fulltext-search.html" target="_blank" rel="external">MySQL 全文索引</a> 或是自己做一个索引（比如说：搜索关键词或是 Tag 什么的）。</p>
<h3 id="5-_在_JOIN_表的时候使用同样类型的例，并将其索引">5. 在 JOIN 表的时候使用同样类型的例，并将其索引</h3><p>如果你的应用程序有很多 JOIN 查询，你应该确认两个表中 JOIN 的字段是被建过索引的。这样 MySQL 内部会启动为你优化 JOIN 的 SQL 语句的机制。</p>
<p>而且，这些被用来 JOIN 的字段，应该是相同类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段 JOIN 在一起，MySQL 就无法使用它们的索引。对于那些 STRING 类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）</p>
<pre><code>// 在<span class="keyword">state</span>中查找company
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT company_name FROM users LEFT JOIN companies ON (users.state = companies.state) WHERE users.id = $user_id"</span>);
// 两个 <span class="keyword">state</span> 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。
</code></pre><h3 id="6-_千万不要_OEDER_BY_RAND()">6. 千万不要 OEDER BY RAND()</h3><p>想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你却不了解这样做有多么可怕的性能问题。</p>
<p>如果你真的想把返回的数据行打乱了，你有 N 种方法可以达到这个目的。这样使用只能让你的数据库的性能呈指数级下降。这里的问题是：MySQL 会不得不去执行 RAND() 函数（很耗 CPU 时间），而且这是为每一行记录去记行，然后再对其排序。就算是你用了 LIMIT 1 也无济于事（因为要排序）。</p>
<p>下面的示例是随机挑一条记录</p>
<pre><code>// 千万不要这样做：
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT username FROM user ORDER BY RAND() LIMIT 1"</span>);

// 这要会更好：
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT count(*) FROM user"</span>);
<span class="variable">$d</span> = mysql_fetch_row(<span class="variable">$r</span>);
<span class="variable">$rand</span> = mt_rand(<span class="number">0</span>,<span class="variable">$d</span>[<span class="number">0</span>] - <span class="number">1</span>);
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT username FROM user LIMIT $rand, 1"</span>);
</code></pre><h3 id="7-_避免_SELECT_*">7. 避免 SELECT *</h3><p>从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和 WEB 服务器是两台独立的服务器的话，这还会增加网络传输的负载。</p>
<p>所以，你应该养成一个需要什么就取什么的好的习惯。</p>
<pre><code>// 不推荐
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT * FROM user WHERE user_id = 1"</span>);
<span class="variable">$d</span> = mysql_fetch_assoc(<span class="variable">$r</span>);
echo <span class="string">"Welcome {$d['username']}"</span>;

// 推荐
<span class="variable">$r</span> = mysql_query(<span class="string">"SELECT username FROM user WHERE user_id = 1"</span>);
<span class="variable">$d</span> = mysql_fetch_assoc(<span class="variable">$r</span>);
echo <span class="string">"Welcome {$d['username']}"</span>;
</code></pre><h3 id="8-_永远为每张表设置一个_ID">8. 永远为每张表设置一个 ID</h3><p>我们应该为数据库里的每张表都设置一个 ID 做为其主键，而且最好的是一个 INT 型的（推荐使用 UNSIGNED ），并设置上自动增加的 AUTO_INCREMENT 标志。</p>
<p>就算是你 users 表有一个主键叫 “ email ”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使性能下降。另外，在你的程序中，你应该使用表的 ID 来构造你的数据结构。</p>
<p>而且，在 MySQL 数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……</p>
<p>在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的 ID，有一个“课程表”有课程 ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生 ID 和课程 ID 叫“外键”其共同组成主键。</p>
<h3 id="9-_使用_ENUM_而不是_VARCHAR">9. 使用 ENUM 而不是 VARCHAR</h3><p><a href="http://dev.mysql.com/doc/refman/5.0/en/enum.html" target="_blank" rel="external">ENUM</a> 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p>
<p>如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</p>
<p>MySQL 也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。</p>
<h3 id="10-_从_PROCEDURE_ANALYSE()_取得建议">10. 从 PROCEDURE ANALYSE() 取得建议</h3><p><a href="http://dev.mysql.com/doc/refman/5.0/en/procedure-analyse.html" target="_blank" rel="external">PROCEDURE ANALYSE()</a> 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。</p>
<p>例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE() 会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。</p>
<p>在 phpmyadmin 里，你可以在查看表时，点击 “ Propose table structure ” 来查看这些建议</p>
<p><img src="/images/201509/suggestions.jpg" alt="procedure"></p>
<p>一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。</p>
<h3 id="11-_尽可能的使用_NOT_NULL">11. 尽可能的使用 NOT NULL</h3><p>除非你有一个很特别的原因去使用 NULL 值，否则你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。</p>
<p>首先，问问你自己“ Empty ”和“ NULL ”有多大的区别（如果是 INT，那就是 0 和 NULL ）？如果你觉得它们之间没有什么区别，那么你就不要使用 NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)</p>
<p>不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用 NULL 了，现实情况是很复杂的，依然会有些情况下，你需要使用 NULL 值。</p>
<p>下面摘自 MySQL 自己的文档：</p>
<pre><code>“ <span class="constant">NULL</span> columns <span class="built_in">require</span> additional <span class="constant">space</span> <span class="operator">in</span> <span class="operator">the</span> row <span class="built_in">to</span> record whether their values are <span class="constant">NULL</span>. For MyISAM tables, <span class="keyword">each</span> <span class="constant">NULL</span> column takes <span class="constant">one</span> bit extra, rounded up <span class="built_in">to</span> <span class="operator">the</span> nearest <span class="keyword">byte</span>.”
</code></pre><h3 id="12-_Prepared_Statements">12. Prepared Statements</h3><p>Prepared Statements 很像存储过程，是一种运行在后台的 SQL 语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</p>
<p>Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“ SQL 注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些 framework 或是 ORM 的时候，这样的问题会好一些。</p>
<p>在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些 Prepared Statements 定义一些参数，而 MySQL 只会解析一次。</p>
<p>因为最新版本的 MySQL 在传输 Prepared Statements 是使用二进制形势，所以这会使得网络传输非常有效率。</p>
<p>当然，也有一些情况下，我们需要避免使用 Prepared Statements，因为其不支持查询缓存。但据说版本 5.1 后支持了。</p>
<p>在 PHP 中要使用 prepared statements ，你可以查看其使用手册：<a href="http://php.net/manual/en/book.mysqli.php" target="_blank" rel="external">mysqli</a> 扩展 或是使用数据库抽象层，如： <a href="http://us.php.net/manual/en/book.pdo.php" target="_blank" rel="external">PDO</a>.</p>
<pre><code>// 创建 prepared statement
<span class="keyword">if</span> (<span class="variable">$stmt</span> = <span class="variable">$mysqli-</span>&gt;prepare(<span class="string">"SELECT username FROM user WHERE state=?"</span>)) {
    // 绑定参数
    <span class="variable">$stmt-</span>&gt;bind_param(<span class="string">"s"</span>, <span class="variable">$state</span>);
    // 执行
    <span class="variable">$stmt-</span>&gt;execute();
    // 绑定结果
    <span class="variable">$stmt-</span>&gt;bind_result(<span class="variable">$username</span>);
    // 移动游标
    <span class="variable">$stmt-</span>&gt;fetch();
    printf(<span class="string">"%s is from %s\n"</span>, <span class="variable">$username</span>, <span class="variable">$state</span>);
    <span class="variable">$stmt-</span>&gt;close();
}
</code></pre><h3 id="13-_无缓冲的查询">13. 无缓冲的查询</h3><p>正常的情况下，当你在你的脚本中执行一个 SQL 语句的时候，你的程序会停在那里直到没这个 SQL 语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。</p>
<p>关于这个事情，在 PHP 的文档中有一个非常不错的说明： <a href="http://php.net/manual/en/function.mysql-unbuffered-query.php" target="_blank" rel="external">mysql_unbuffered_query()</a> 函数：</p>
<pre><code>“ mysql_unbuffered_query() sends the <span class="type">SQL</span> query query to <span class="type">MySQL</span> <span class="keyword">without</span> automatically fetching <span class="keyword">and</span> buffering the <span class="literal">result</span> rows <span class="keyword">as</span> mysql_query() does. <span class="type">This</span> saves a considerable amount <span class="keyword">of</span> memory <span class="keyword">with</span> <span class="type">SQL</span> queries that produce large <span class="literal">result</span> sets, <span class="keyword">and</span> you can start working on the <span class="literal">result</span> <span class="type">set</span> immediately after the first row has been retrieved <span class="keyword">as</span> you don’t have to wait until the complete <span class="type">SQL</span> query has been performed. ”
</code></pre><p>上面那句话翻译过来是说，mysql_unbuffered_query() 发送一个 SQL 语句到 MySQL 而并不像 mysql_query() 一样去自动 fethch 和缓存结果。这会相当节约很多可观的内存，尤其是那些会产生大量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。</p>
<p>然而，这会有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用 <a href="http://us2.php.net/manual/en/function.mysql-free-result.php" target="_blank" rel="external">mysql_free_result()</a> 清除结果。而且， <a href="http://us2.php.net/manual/en/function.mysql-num-rows.php" target="_blank" rel="external">mysql_num_rows()</a> 或 <a href="http://us2.php.net/manual/en/function.mysql-data-seek.php" target="_blank" rel="external">mysql_data_seek()</a> 将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。</p>
<h3 id="14-_把_IP_地址存成_UNSIGNED_INT">14. 把 IP 地址存成 UNSIGNED INT</h3><p>很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的 IP 而不是整型的 IP 。如果你用整型来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的 WHERE 条件：IP between ip1 and ip2。</p>
<p>我们必需要使用 UNSIGNED INT ，因为 IP 地址会使用整个 32 位的无符号整型。</p>
<p>而你的查询，你可以使用 <a href="http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_inet-aton" target="_blank" rel="external">INET_ATON()</a> 来把一个字符串 IP 转成一个整形，并使用 <a href="http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_inet-ntoa" target="_blank" rel="external">INET_NTOA()</a> 把一个整型转成一个字符串 IP 。在 PHP 中，也有这样的函数 <a href="http://php.net/manual/en/function.ip2long.php" target="_blank" rel="external">ip2long()</a> 和 <a href="http://us.php.net/manual/en/function.long2ip.php" target="_blank" rel="external">long2ip()</a>。</p>
<pre><code>$r = "<span class="operator"><span class="keyword">UPDATE</span> <span class="keyword">users</span> <span class="keyword">SET</span> ip = <span class="keyword">INET_ATON</span>(<span class="string">'{$_SERVER['</span>REMOTE_ADDR<span class="string">']}'</span>) <span class="keyword">WHERE</span> user_id = $user_id<span class="string">";</span></span>
</code></pre><h3 id="15-_固定长度的表会更快">15. 固定长度的表会更快</h3><p>如果表中的所有字段都是“固定长度”的，整个表会被认为是 <a href="">“static”</a> 或 <a href="">“fixed-length”</a>。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。</p>
<p>固定长度的表会提高性能，因为 MySQL 搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</p>
<p>并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p>
<p>使用“垂直分割”技术（见下一条），你可以把表分割成两个：一个是定长的，一个则是不定长的。</p>
<h3 id="16-_垂直分割">16. 垂直分割</h3><p>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有 100 多个字段，很恐怖）</p>
<p>示例一：在 Users 表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户 ID ，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。</p>
<p>示例二： 你有一个叫 “ last_login ” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户 ID ，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。</p>
<p>另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去 JOIN 他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。</p>
<h3 id="17-_拆分大的_DELETE_或_INSERT_语句">17. 拆分大的 DELETE 或 INSERT 语句</h3><p>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止响应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</p>
<p>Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。</p>
<p>如果你把你的表锁上一段时间，比如 30 秒钟，那么对于一个有很高访问量的站点来说，这 30 秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊 WEB 服务 Crash ，还可能会让你的整台服务器马上掛了。</p>
<p>所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：</p>
<pre><code><span class="keyword">while</span> (<span class="number">1</span>) {
    <span class="comment">//每次只做1000条</span>
    mysql_query(<span class="string">"DELETE FROM logs WHERE log_date &lt;= '2009-11-01' LIMIT 1000"</span>);
    <span class="keyword">if</span> (mysql_affected_rows() == <span class="number">0</span>) {
    <span class="comment">// 没得可删了，退出！</span>
    <span class="keyword">break</span>;
    }
    <span class="comment">// 每次都要休息一会儿</span>
    usleep(<span class="number">50000</span>);
}
</code></pre><h3 id="18-_越小的列会越快">18. 越小的列会越快</h3><p>对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。</p>
<p>参看 MySQL 的文档 <a href="http://dev.mysql.com/doc/refman/5.0/en/storage-requirements.html" target="_blank" rel="external">Storage Requirements</a> 查看所有的数据类型。</p>
<p>如果一个表只有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。</p>
<p>当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看 <a href="http://slashdot.org/story/06/11/09/1534204/slashdot-posting-bug-infuriates-haggard-admins" target="_blank" rel="external">Slashdot</a> 的例子（ 2009 年 11 月 06 日），一个简单的 ALTER TABLE 语句花了 3 个多小时，因为里面有一千六百万条数据。</p>
<h3 id="19-_选择正确的存储引擎">19. 选择正确的存储引擎</h3><p>在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章<a href="http://coolshell.cn/articles/652.html" target="_blank" rel="external">《MySQL: InnoDB 还是 MyISAM?》</a>讨论和这个事情。</p>
<p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到写操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p>
<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<p>下面是MySQL的手册</p>
<ul>
<li><a href="http://dev.mysql.com/doc/refman/5.1/en/myisam-storage-engine.html" target="_blank" rel="external">target=”_blank”MyISAM Storage Engine</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.1/en/innodb.html" target="_blank" rel="external">InnoDB Storage Engine</a></li>
</ul>
<h3 id="20-_使用一个对象关系映射器（Object_Relational_Mapper）">20. 使用一个对象关系映射器（Object Relational Mapper）</h3><p>使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个 ORM 可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。</p>
<p>ORM 的最重要的是“ Lazy Loading ”，也就是说，只有在需要去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。</p>
<p>ORM 还可以把你的 SQL 语句打包成一个事务，这会比单独执行他们快得多得多。</p>
<p>目前，个人最喜欢 PHP 的 ORM 是：<a href="http://www.doctrine-project.org/" target="_blank" rel="external">Doctrine</a>。</p>
<h3 id="21-_小心“永久链接”">21. 小心“永久链接”</h3><p>“永久链接”的目的是用来减少重新创建 MySQL 链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的 Apache 开始重用它的子进程后——也就是说，下一次的 HTTP 请求会重用 Apache 的子进程，并重用相同的 MySQL 链接。</p>
<ul>
<li><a href="">PHP手册：mysql_pconnect()</a></li>
</ul>
<p>在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。</p>
<p>而且，Apache 运行在极端并行的环境中，会创建很多很多的子进程。这就是为什么这种“永久链接”机制工作不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。</p>
<h3 id="22-_引用">22. 引用</h3><p><a href="http://coolshell.cn/articles/1846.html" target="_blank" rel="external">http://coolshell.cn/articles/1846.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们]]>
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP程序员的技术成长规划（转）]]></title>
    <link href="http://yoursite.com/2015/10/09/PHP%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2015/10/09/PHP程序员的技术成长规划/</id>
    <published>2015-10-08T17:29:02.000Z</published>
    <updated>2015-10-08T17:37:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>按照了解的很多PHP/LNMP程序员的发展轨迹，结合个人经验体会，抽象出很多程序员对未来的迷漫，特别对技术学习的盲目和慌乱，简单梳理了这个每个阶段PHP程序员的技术要求，来帮助很多PHP程序做对照设定学习成长目标。<br>本文按照目前主流技术做了一个基本的梳理，整个是假设PHP程序员不是基础非常扎实的情况进行的设定，并且所有设定都非常具体明确清晰，可能会让人觉得不适，请理解仅代表一家之言。（未来技术变化不在讨论范围）</p>
<h3 id="第一阶段：基础阶段">第一阶段：基础阶段</h3><p>重点：把LNMP搞熟练（核心是安装配置基本操作）<br>目标：能够完成基本的LNMP系统安装，简单配置维护；能够做基本的简单系统的PHP开发；能够在PHP中型系统中支持某个PHP功能模块的开发。<br>时间：完成本阶段的时间因人而异，有的成长快半年一年就过了，成长慢的两三年也有。</p>
<h4 id="Linux">Linux</h4><p>基本命令、操作、启动、基本服务配置（包括rpm安装文件，各种服务配置等）；会写简单的shell脚本和awk/sed 脚本命令等。</p>
<h4 id="Nginx">Nginx</h4><p>做到能够安装配置nginx+php，知道基本的nginx核心配置选项，知道 server/fastcgi_pass/access_log 等基础配置，目标是能够让nginx+php_fpm顺利工作。</p>
<h4 id="MySQL">MySQL</h4><p>会自己搭建mysql，知道基本的mysql配置选项；知道innodb和myisam的区别，知道针对InnoDB和MyISAM两个引擎的不同配置选项；知道基本的两个引擎的差异和选择上面的区别；能够纯手工编译搭建一个MySQL数据库并且配置好编码等正常稳定运行；核心主旨是能够搭建一个可运行的MySQL数据库。</p>
<h4 id="PHP">PHP</h4><p>基本语法数组、字符串、数据库、XML、Socket、GD/ImageMgk图片处理等等；熟悉各种跟MySQL操作链接的api（mysql/mysqli/PDO)，知道各种编码问题的解决；知道常规熟练使用的PHP框架（ThinkPHP、Zendframework、Yii、Yaf等）；了解基本MVC的运行机制和为什么这么做，稍微知道不同的PHP框架之间的区别；能够快速学习一个MVC框架。能够知道开发工程中的文件目录组织，有基本的良好的代码结构和风格，能够完成小系统的开发和中型系统中某个模块的开发工作。</p>
<h4 id="前端">前端</h4><p>如果条件时间允许，可以适当学习下 HTML/CSS/JS 等相关知识，知道什么web标准，div+css的web/wap页面模式，知道HTML5和HTML4的区别；了解一些基本的前端只是和JS框架（jQuery之类的）；了解一些基本的JavaScript编程知识；（本项不是必须项，如果有时间，稍微了解一下是可以的，不过不建议作为重点，除非个人有强烈兴趣）</p>
<h4 id="系统设计">系统设计</h4><p>能够完成小型系统的基本设计，包括简单的数据库设计，能够完成基本的：浏览器 -&gt; Nginx+PHP -&gt; 数据库 架构的设计开发工作；能够支撑每天几十万到数百万流量网站的开发维护工作；</p>
<h3 id="第二阶段：提高阶段">第二阶段：提高阶段</h3><p>重点：提高针对LNMP的技能，能够更全面的对LNMP有熟练的应用。<br>目标：能够随时随地搭建好LNMP环境，快速完成常规配置；能够追查解决大部分遇到的开发和线上环境的问题；能够独立承担中型系统的构架和开发工作；能够在大型系统中承担某个中型模块的开发工作；</p>
<h4 id="Linux-1">Linux</h4><p>在第一阶段的基础上面，能够流畅的使用Shell脚本来完成很多自动化的工作；awk/sed/perl 也操作的不错，能够完成很多文本处理和数据统计等工作；基本能够安装大部分非特殊的Linux程序（包括各种库、包、第三方依赖等等，比如MongoDB/Redis/Sphinx/Luncene/SVN之类的）；了解基本的Linux服务，知道如何查看Linux的性能指标数据，知道基本的Linux下面的问题跟踪等。</p>
<h4 id="Nginx-1">Nginx</h4><p>在第一阶段的基础上面，了解复杂一些的Nginx配置；包括 多核配置、events、proxypass，sendfile/tcp*配置，知道超时等相关配置和性能影响；知道nginx除了web server，还能够承担代理服务器、反向静态服务器等配置；知道基本的nginx配置调优；知道如何配置权限、编译一个nginx扩展到nginx；知道基本的nginx运行原理（master/worker机制，epoll），知道为什么nginx性能比apache性能好等知识；</p>
<h4 id="MySQL/MongoDB">MySQL/MongoDB</h4><p>在第一阶段的基础上面，在MySQL开发方面，掌握很多小技巧，包括常规SQL优化（group by/order by/rand优化等）；除了能够搭建MySQL，还能够冷热备份MySQL数据，还知道影响innodb/myisam性能的配置选项（比如key_buffer/query_cache/sort_buffer/innodb_buffer_pool_size/innodb_flush_log_at_trx_commit等），也知道这些选项配置成为多少值合适；另外也了解一些特殊的配置选项，比如 知道如何搭建mysql主从同步的环境，知道各个binlog_format的区别；知道MySQL的性能追查，包括slow_log/explain等，还能够知道基本的索引建立处理等知识；原理方面了解基本的MySQL的架构（Server+存储引擎），知道基本的InnoDB/MyISAM索引存储结构和不同（聚簇索引，B树）；知道基本的InnoDB事务处理机制；了解大部分MySQL异常情况的处理方案（或者知道哪儿找到处理方案）。条件允许的情况，建议了解一下NoSQL的代表MongoDB数据库，顺便对比跟MySQL的差别，同事能够在合适的应用场景安全谨慎的使用MongoDB，知道基本的PHP与MongoDB的结合开发。</p>
<h4 id="Redis/Memcached">Redis/Memcached</h4><p>在大部分中型系统里面一定会涉及到缓存处理，所以一定要了解基本的缓存；知道Memcached和Redis的异同和应用场景，能够独立安装 Redis/Memcached，了解Memcahed的一些基本特性和限制，比如最大的value值，知道PHP跟他们的使用结合；Redis了解基本工作原理和使用，了解常规的数据类型，知道什么场景应用什么类型，了解Redis的事务等等。原理部分，能够大概了解Memcached的内存结构（slab机制），redis就了解常用数据类型底层实现存储结构（SDS/链表/SkipList/HashTable）等等，顺便了解一下Redis的事务、RDB、AOF等机制更好</p>
<h4 id="PHP-1">PHP</h4><p>除了第一阶段的能力，安装配置方面能够随意安装PHP和各种第三方扩展的编译安装配置；了解php-fpm的大部分配置选项和含义（如max_requests/max_children/request_terminate_timeout之类的影响性能的配置），知道mod_php/fastcgi的区别；在PHP方面已经能够熟练各种基础技术，还包括各种深入些的PHP，包括对PHP面向对象的深入理解/SPL/语法层面的特殊特性比如反射之类的；在框架方面已经阅读过最少一个以上常规PHP MVC框架的代码了，知道基本PHP框架内部实现机制和设计思想；在PHP开发中已经能够熟练使用常规的设计模式来应用开发（抽象工厂/单例/观察者/命令链/策略/适配器 等模式）；建议开发自己的PHP MVC框架来充分让开发自由化，让自己深入理解MVC模式，也让自己能够在业务项目开发里快速升级；熟悉PHP的各种代码优化方法，熟悉大部分PHP安全方面问题的解决处理；熟悉基本的PHP执行的机制原理（Zend引擎/扩展基本工作机制）；</p>
<h4 id="C/C++">C/C++</h4><p>开始涉猎一定的C/C++语言，能够写基本的C/C++代码，对基本的C/C++语法熟悉（指针、数组操作、字符串、常规标准API）和数据结构（链表、树、哈希、队列）有一定的熟悉下；对Linux下面的C语言开发有基本的了解概念，会简单的makefile文件编写，能够使用简单的GCC/GDB的程序编译简单调试工作；对基本的网络编程有大概了解。（本项是为了向更高层次打下基础）</p>
<h4 id="前端-1">前端</h4><p>在第一阶段的基础上面，熟悉基本的HTTP协议（协议代码200/300/400/500，基本的HTTP交互头）；条件允许，可以在深入写出稍微优雅的HTML+CSS+JavaScript，或者能够大致简单使用某些前端框架（jQuery/YUI/ExtJS/RequireJS/BootStrap之类）；如果条件允许，可以深入学习JavaScript编程，比如闭包机制、DOM处理；再深入些可以读读jQuery源码做深入学习。（本项不做重点学习，除非对前端有兴趣）</p>
<h4 id="系统设计-1">系统设计</h4><p>能够设计大部分中型系统的网站架构、数据库、基本PHP框架选型；性能测试排查处理等；能够完成类似：浏览器 -&gt; CDN(Squid) -&gt; Nginx+PHP -&gt; 缓存 -&gt; 数据库 结构网站的基本设计开发维护；能够支撑每天数百万到千万流量基本网站的开发维护工作；</p>
<h3 id="第三阶段：高级阶段">第三阶段：高级阶段</h3><p>重点：除了基本的LNMP程序，还能够在某个方向或领域有深入学习。（纵深维度发展）<br>目标：除了能够完成基本的PHP业务开发，还能够解决大部分深入复杂的技术问题，并且可以独立设计完成中大型的系统设计和开发工作；自己能够独立hold深入某个技术方向，在这块比较专业。（比如在MySQL、Nginx、PHP、Redis等等任一方向深入研究）</p>
<h4 id="Linux-2">Linux</h4><p>除了第二阶段的能力，在Linux下面除了常规的操作和性能监控跟踪，还能够使用很多高级复杂的命令完成工作（watch/tcpdump/starce/ldd/ar等)；在shell脚本方面，已经能够编写比较复杂的shell脚本（超过500行）来协助完成很多包括备份、自动化处理、监控等工作的shell；对awk/sed/perl 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据；对Linux内部机制有一些了解，对内核模块加载，启动错误处理等等有个基本的处理；同时对一些其他相关的东西也了解，比如NFS、磁盘管理等等；</p>
<h4 id="Nginx-2">Nginx</h4><p>在第二阶段的基础上面，已经能够把Nginx操作的很熟练，能够对Nginx进行更深入的运维工作，比如监控、性能优化，复杂问题处理等等；看个人兴趣，更多方面可以考虑侧重在关于Nginx工作原理部分的深入学习，主要表现在阅读源码开始，比如具体的master/worker工作机制，Nginx内部的事件处理，内存管理等等；同时可以学习Nginx扩展的开发，可以定制一些自己私有的扩展；同时可以对Nginx+Lua有一定程度的了解，看看是否可以结合应用出更好模式；这个阶段的要求是对Nginx原理的深入理解，可以考虑成为Nginx方向的深入专业者。</p>
<h4 id="MySQL/MongoDB-1">MySQL/MongoDB</h4><p>在第二阶段的基础上面，在MySQL应用方面，除了之前的基本SQL优化，还能够在完成一些复杂操作，比如大批量数据的导入导出，线上大批量数据的更改表结构或者增删索引字段等等高危操作；除了安装配置，已经能够处理更多复杂的MySQL的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房同步数据方案、MySQL高可用架构等都有涉及了解；对MySQL应用层面，对MySQL的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触发器、分区等技术有一定了解和应用；对MySQL性能方面，有包括磁盘优化（SAS迁移到SSD）、服务器优化（内存、服务器本身配置）、除了二阶段的其他核心性能优化选项（innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout等）、连接池软件选择应用，对show *（show status/show profile）类的操作语句有深入了解，能够完成大部分的性能问题追查；MySQL备份技术的深入熟悉，包括灾备还原、对Binlog的深入理解，冷热备份，多IDC备份等；在MySQL原理方面，有更多了解，比如对MySQL的工作机制开始阅读部分源码，比如对主从同步（复制）技术的源码学习，或者对某个存储引擎（MyISAM/Innodb/TokuDB）等等的源码学习理解，如果条件允许，可以参考CSV引擎开发自己简单的存储引擎来保存一些数据，增强对MySQL的理解；在这个过程，如果自己有兴趣，也可以考虑往DBA方向发展。MongoDB层面，可以考虑比如说在写少读多的情况开始在线上应用MongoDB，或者是做一些线上的数据分析处理的操作，具体场景可以按照工作来，不过核心是要更好的深入理解RMDBS和NoSQL的不同场景下面的应用，如果条件或者兴趣允许，可以开始深入学习一下MongoDB的工作机制。</p>
<h4 id="Redis/Memcached-1">Redis/Memcached</h4><p>在第二阶段的基础上面，能够更深入的应用和学习。因为Memcached不是特别复杂，建议可以把源码进行阅读，特别是内存管理部分，方便深入理解；Redis部分，可以多做一些复杂的数据结构的应用（zset来做排行榜排序操作/事务处理用来保证原子性在秒杀类场景应用之类的使用操作）；多涉及aof等同步机制的学习应用，设计一个高可用的Redis应用架构和集群；建议可以深入的学习一下Redis的源码，把在第二阶段积累的知识都可以应用上，特别可以阅读一下包括核心事件管理、内存管理、内部核心数据结构等充分学习了解一下。如果兴趣允许，可以成为一个Redis方面非常专业的使用者。</p>
<h4 id="PHP-2">PHP</h4><p>作为基础核心技能，我们在第二阶段的基础上面，需要有更深入的学习和应用。从基本代码应用上面来说，能够解决在PHP开发中遇到95%的问题，了解大部分PHP的技巧；对大部分的PHP框架能够迅速在一天内上手使用，并且了解各个主流PHP框架的优缺点，能够迅速方便项目开发中做技术选型；在配置方面，除了常规第二阶段会的知识，会了解一些比较偏门的配置选项（php auto_prepend_file/auto_append_file），包括扩展中的一些复杂高级配置和原理（比如memcached扩展配置中的memcache.hash_strategy、apc扩展配置中的apc.mmap_file_mask/apc.slam_defense/apc.file_update_protection之类的）；对php的工作机制比较了解，包括php-fpm工作机制（比如php-fpm在不同配置机器下面开启进程数量计算以及原理），对zend引擎有基本熟悉（vm/gc/stream处理），阅读过基本的PHP内核源码（或者阅读过相关文章），对PHP内部机制的大部分核心数据结构（基础类型/Array/Object）实现有了解，对于核心基础结构（zval/hashtable/gc）有深入学习了解；能够进行基本的PHP扩展开发，了解一些扩展开发的中高级知识（minit/rinit等），熟悉php跟apache/nginx不同的通信交互方式细节（mod_php/fastcgi）；除了开发PHP扩展，可以考虑学习开发Zend扩展，从更底层去了解PHP。</p>
<h4 id="C/C++-1">C/C++</h4><p>在第二阶段基础上面，能够在C/C++语言方面有更深入的学习了解，能够完成中小型C/C++系统的开发工作；除了基本第二阶段的基础C/C++语法和数据结构，也能够学习一些特殊数据结构（b-tree/rb-tree/skiplist/lsm-tree/trie-tree等）方便在特殊工作中需求；在系统编程方面，熟悉多进程、多线程编程；多进程情况下面了解大部分多进程之间的通信方式，能够灵活选择通信方式（共享内存/信号量/管道等）；多线程编程能够良好的解决锁冲突问题，并且能够进行多线程程序的开发调试工作；同时对网络编程比较熟悉，了解多进程模型/多线程模型/异步网络IO模型的差别和选型，熟悉不同异步网络IO模型的原理和差异（select/poll/epoll/iocp等），并且熟悉常见的异步框架（ACE/ICE/libev/libevent/libuv/Boost.ASIO等）和使用，如果闲暇也可以看看一些国产自己开发的库（比如muduo）；同时能够设计好的高并发程序架构（leader-follow/master-worker等）；了解大部分C/C++后端Server开发中的问题（内存管理、日志打印、高并发、前后端通信协议、服务监控），知道各个后端服务RPC通信问题（struct/http/thirft/protobuf等）；能够更熟络的使用GCC和GDB来开发编译调试程序，在线上程序core掉后能够迅速追查跟踪解决问题；通用模块开发方面，可以积累或者开发一些通用的工具或库（比如异步网络框架、日志库、内存池、线程池等），不过开发后是否应用要谨慎，省的埋坑去追bug；</p>
<h4 id="前端-2">前端</h4><p>深入了解HTTP协议（包括各个细致协议特殊协议代码和背后原因，比如302静态文件缓存了，502是nginx后面php挂了之类的）；除了之前的前端方面的各种框架应用整合能力，前端方面的学习如果有兴趣可以更深入，表现形式是，可以自己开发一些类似jQuery的前端框架，或者开发一个富文本编辑器之类的比较琐碎考验JavaScript功力；</p>
<h4 id="其他领域语言学习">其他领域语言学习</h4><p>在基础的PHP/C/C++语言方面有基本积累，建议在当前阶段可以尝试学习不同的编程语言，看个人兴趣爱好，脚本类语言可以学学 Python/Ruby 之类的，函数式编程语言可以试试 Lisp/Haskell/Scala/Erlang 之类的，静态语言可以试试 Java/Golang，数据统计分析可以了解了解R语言，如果想换个视角做后端业务，可以试试 Node.js还有前面提到的跟Nginx结合的Nginx_Lua等。学习不同的语言主要是提升自己的视野和解决问题手段的差异，比如会了解除了进程/线程，还有轻量级协程；比如在跨机器通信场景下面，Erlang的解决方案简单的惊人；比如在不想选择C/C++的情况下，还有类似高效的Erlang/Golang可用等等；主要是提升视野。</p>
<h4 id="其他专业方向学习">其他专业方向学习</h4><p>在本阶段里面，会除了基本的LNMP技能之外，会考虑一些其他领域知识的学习，这些都是可以的，看个人兴趣和长期的目标方向。目前情况能够选择的领域比较多，比如、云计算（分布式存储、分布式计算、虚拟机等），机器学习（数据挖掘、模式识别等，应用到统计、个性化推荐），自然语言处理（中文分词等），搜索引擎技术、图形图像、语音识别等等。除了这些高大上的，也有很多偏工程方面可以学习的地方，比如高性能系统、移动开发（Android/IOS）、计算机安全、嵌入式系统、硬件等方向。</p>
<h4 id="系统设计-2">系统设计</h4><p>系统设计在第二阶段的基础之上，能够应用掌握的经验技能，设计出比较复杂的中大型系统，能够解决大部分线上的各种复杂系统的问题，完成类似 浏览器 -&gt; CDN -&gt; 负载均衡 -&gt;接入层 -&gt; Nginx+PHP -&gt; 业务缓存 -&gt; 数据库 -&gt; 各路复杂后端RPC交互（存储后端、逻辑后端、反作弊后端、外部服务） -&gt; 更多后端 酱紫的复杂业务；能够支撑每天数千万到数亿流量网站的正常开发维护工作。</p>
<h3 id="第四阶段：架构阶段">第四阶段：架构阶段</h3><p>ps: 暂时不展开讨论，等下次专门撰文来描述补充本部分内容</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="概述">概述</h3><p>按照了解的很多PHP/LNMP程序员的发展轨迹，结合个人经验体会，抽象出很多程序员对未来的迷漫，特别对技术学习的盲目和慌乱，简单梳理了这个每个阶段PHP程序员的技术要求，来帮助很多PHP程序做对照设定学习成长目标。<br>本文按照目前主]]>
    </summary>
    
      <category term="［php,其他］" scheme="http://yoursite.com/tags/%EF%BC%BBphp-%E5%85%B6%E4%BB%96%EF%BC%BD/"/>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[json.stringify() 和 json.parse()]]></title>
    <link href="http://yoursite.com/2015/10/07/json-stringify-%E5%92%8C-json-parse/"/>
    <id>http://yoursite.com/2015/10/07/json-stringify-和-json-parse/</id>
    <published>2015-10-07T15:24:43.000Z</published>
    <updated>2015-10-07T15:37:48.000Z</updated>
    <content type="html"><![CDATA[<h4 id="stringify()_把一个对象、数组等解析成字符串格式">stringify() 把一个对象、数组等解析成字符串格式</h4><pre><code><span class="variable"><span class="keyword">var</span> obj</span> = {a:<span class="number">1</span>,b:<span class="number">2</span>,c:<span class="number">3</span>};
json.stringify(obj);

结果：
'{<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>,<span class="string">"c"</span>:<span class="number">3</span>}'
</code></pre><h4 id="parse()_把一个字符串解析成_json_对象">parse() 把一个字符串解析成 json 对象</h4><pre><code><span class="variable"><span class="keyword">var</span> str</span> = '{<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>,<span class="string">"c"</span>:<span class="number">3</span>}';
json.parse(str);

结果：
{a:<span class="number">1</span>,b:<span class="number">2</span>,c:<span class="number">3</span>}
</code></pre><p>未作更深的研究，以后有时间在补充。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="stringify()_把一个对象、数组等解析成字符串格式">stringify() 把一个对象、数组等解析成字符串格式</h4><pre><code><span class="variable"><span class="keyword">var</span> ]]>
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
      <category term="parse" scheme="http://yoursite.com/tags/parse/"/>
    
      <category term="stringify" scheme="http://yoursite.com/tags/stringify/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[渗透测试必备－Firefox全套渗透装]]></title>
    <link href="http://yoursite.com/2015/09/30/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%8DFirefox%E5%85%A8%E5%A5%97%E6%B8%97%E9%80%8F%E8%A3%85/"/>
    <id>http://yoursite.com/2015/09/30/渗透测试必备－Firefox全套渗透装/</id>
    <published>2015-09-30T03:11:02.000Z</published>
    <updated>2015-10-10T09:13:18.000Z</updated>
    <content type="html"><![CDATA[<p>工欲善必先利其器，firefox一直是各位渗透师必备的利器，小编这里推荐34款firefox渗透测试辅助插件，其中包含渗透测试、信息收集、代理、加密解密等功能。</p>
<h3 id="1-_Firebug">1. <a href="https://addons.mozilla.org/en-US/firefox/addon/firebug/" target="_blank" rel="external">Firebug</a></h3><p>Firefox的 五星级强力推荐插件之一，不需要多解释 </p>
<h3 id="2-_User_Agent_Switcher">2. <a href="https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/" target="_blank" rel="external">User Agent Switcher</a></h3><p>改变客户端的User Agent的一款插件</p>
<h3 id="3-_Hackbar">3. <a href="https://addons.mozilla.org/en-US/firefox/addon/hackbar/" target="_blank" rel="external">Hackbar</a></h3><p>91ri.org的攻城师们的必备工具，提供了SQL注入和XSS攻击，能够快速对字符串进行各种编码。</p>
<h3 id="4-_HttpFox">4. <a href="https://addons.mozilla.org/en-US/firefox/addon/httpfox/" target="_blank" rel="external">HttpFox</a></h3><p>监测和分析浏览器与web服务器之间的HTTP流量</p>
<h3 id="5-_Live_HTTP_Headers">5. <a href="https://addons.mozilla.org/en-US/firefox/addon/live-http-headers/" target="_blank" rel="external">Live HTTP Headers</a></h3><p>即时查看一个网站的HTTP头</p>
<h3 id="6-_Tamper_Data">6. <a href="https://addons.mozilla.org/en-US/firefox/addon/tamper-data/" target="_blank" rel="external">Tamper Data</a></h3><p>查看和修改HTTP/HTTPS头和POST参数</p>
<h3 id="7-_ShowIP">7. <a href="https://addons.mozilla.org/en-US/firefox/addon/showip/" target="_blank" rel="external">ShowIP</a></h3><p>在状态栏显示当前页的IP地址、主机名、ISP、国家和城市等信息。</p>
<h3 id="8-_OSVDB">8. <a href="https://addons.mozilla.org/en-us/firefox/addon/osvdb/" target="_blank" rel="external">OSVDB</a></h3><p>开放源码的漏洞数据库检索</p>
<h3 id="9-_Packet_Storm_search_plugin">9. <a href="https://addons.mozilla.org/en-us/firefox/addon/packet-storm-search-plugin/" target="_blank" rel="external">Packet Storm search plugin</a></h3><p>Packet Storm提供的插件，可以搜索漏洞、工具和exploits等。</p>
<h3 id="10-_Offsec_Exploit-db_Search">10. <a href="https://addons.mozilla.org/en-us/firefox/addon/offsec-exploit-db-search/" target="_blank" rel="external">Offsec Exploit-db Search</a></h3><p>搜索Exploit-db信息</p>
<h3 id="11-_Security_Focus_Vulnerabilities_Search_Plugin">11. <a href="https://addons.mozilla.org/en-us/firefox/addon/securityfocus-vulnerabilities-/" target="_blank" rel="external">Security Focus Vulnerabilities Search Plugin</a></h3><p>在Security Focus上搜索漏洞</p>
<h3 id="12-_Cookie_Watcher">12. <a href="https://addons.mozilla.org/en-us/firefox/addon/watcher/" target="_blank" rel="external">Cookie Watcher</a></h3><p>在状态栏显示cookie</p>
<h3 id="13-_Header_Spy">13. <a href="https://addons.mozilla.org/en-us/firefox/addon/header-spy/" target="_blank" rel="external">Header Spy</a></h3><p>在状态栏显示HTTP头</p>
<h3 id="14-_Groundspeed">14. <a href="https://addons.mozilla.org/en-us/firefox/addon/groundspeed/" target="_blank" rel="external">Groundspeed</a></h3><p>Manipulate the application user interface.</p>
<h3 id="15-_CipherFox">15. <a href="https://addons.mozilla.org/en-us/firefox/addon/cipherfox/" target="_blank" rel="external">CipherFox</a></h3><p>在状态栏显示当前SSL/TLS的加密算法和证书</p>
<h3 id="16-_XSS_Me">16. <a href="https://addons.mozilla.org/en-us/firefox/addon/xss-me/" target="_blank" rel="external">XSS Me</a></h3><p>XSS测试扩展</p>
<h3 id="17-_SQL_Inject_Me">17. <a href="https://addons.mozilla.org/en-us/firefox/addon/sql-inject-me/" target="_blank" rel="external">SQL Inject Me</a></h3><p>SQL注入测试扩展</p>
<h3 id="18-_Wappalyzer">18. <a href="https://addons.mozilla.org/en-us/firefox/addon/wappalyzer/" target="_blank" rel="external">Wappalyzer</a></h3><p>查看网站使用的应用程序</p>
<h3 id="19-_Poster">19. <a href="https://addons.mozilla.org/en-us/firefox/addon/poster/" target="_blank" rel="external">Poster</a></h3><p>发送与Web服务器交互的HTTP请求，并查看输出结果</p>
<h3 id="20-_Javascript_Deobfuscator">20. <a href="https://addons.mozilla.org/en-us/firefox/addon/deobfuscator/" target="_blank" rel="external">Javascript Deobfuscator</a></h3><p>显示网页上运行的Javascript代码</p>
<h3 id="21-_Modify_Headers">21. <a href="https://addons.mozilla.org/en-us/firefox/addon/modify-headers/" target="_blank" rel="external">Modify Headers</a></h3><p>修改HTTP请求头</p>
<h3 id="22-_FoxyProxy">22. <a href="https://addons.mozilla.org/en-us/firefox/addon/foxyproxy-standard/" target="_blank" rel="external">FoxyProxy</a></h3><p>代理工具</p>
<h3 id="23-_FlagFox">23. <a href="https://addons.mozilla.org/en-us/firefox/addon/flagfox/" target="_blank" rel="external">FlagFox</a></h3><p>可以在地址栏或状态栏上显示出当前网站所在国家的国旗，也有更多的其他功能，如：双击国旗可以实现WOT功能；鼠标中键点击是whois功能。当然用户可以在选项里设置快捷键实现诸如复制IP，维基百科查询等功能。</p>
<h3 id="24-_Greasemonkey">24. <a href="https://addons.mozilla.org/en-us/firefox/addon/greasemonkey/" target="_blank" rel="external">Greasemonkey</a></h3><p>greasemonkey 使你可以向任何网页添加DHTML语句(用户脚本)来改变它们的显示方式。就像CSS可以让你接管网页的样式，而用户脚本(User Script)则可以让你轻易地控制网页设计与交互的任何方面。例如:</p>
<ul>
<li>使页面上显示的 URL 都成为可以直接点击进入的链接。</li>
<li>增强网页实用性，使你经常访问的网站更符合你的习惯。</li>
<li>绕过网站上经常出现的那些烦人的 Bug。</li>
</ul>
<h3 id="25-_Domain_Details">25. <a href="https://addons.mozilla.org/en-us/firefox/addon/domain-details/" target="_blank" rel="external">Domain Details</a></h3><p>显示服务器类型、IP地址、域名注册信息等</p>
<h3 id="26-_Websecurify">26. <a href="https://addons.mozilla.org/en-us/firefox/addon/websecurify/" target="_blank" rel="external">Websecurify</a></h3><p>Websecurify是WEB安全检测软件的Firefox的扩展，可以针对Web应用进行安全评估</p>
<h3 id="27-_XSSed_Search">27. <a href="https://addons.mozilla.org/en-us/firefox/addon/xssed-search/" target="_blank" rel="external">XSSed Search</a></h3><p>搜索XSSed.Com跨站脚本数据库</p>
<h3 id="28-_ViewStatePeeker">28. <a href="https://addons.mozilla.org/en-us/firefox/addon/viewstatepeeker/" target="_blank" rel="external">ViewStatePeeker</a></h3><p>查看asp.net的iewState</p>
<h3 id="29-_CryptoFox">29. <a href="https://addons.mozilla.org/en-US/firefox/addon/cryptofox/" target="_blank" rel="external">CryptoFox</a></h3><p>破解MD5、加密/解密工具</p>
<h3 id="30-_WorldIP">30. <a href="https://addons.mozilla.org/en-US/firefox/addon/worldip-flag-and-datacenter-pi/" target="_blank" rel="external">WorldIP</a></h3><p>显示服务器的IP、地址、PING、Traceroute、RDNS等信息</p>
<h3 id="31-_Server_Spy">31. <a href="https://addons.mozilla.org/en-US/firefox/addon/server-spy/" target="_blank" rel="external">Server Spy</a></h3><p>识别访问的web服务器类型，版本以及IP地址的插件</p>
<h3 id="32-_Default_Passwords">32. <a href="https://addons.mozilla.org/en-US/firefox/addon/default-passwords-cirtne-58786/" target="_blank" rel="external">Default Passwords</a></h3><p>搜索CIRT.net默认密码数据库。</p>
<h3 id="33-_Snort_IDS_Rule_Search">33. <a href="https://addons.mozilla.org/en-US/firefox/addon/snort-ids-rule-search/" target="_blank" rel="external">Snort IDS Rule Search</a></h3><p>搜索Snort的IDS规则，做签名开发的应该很有用。</p>
<h3 id="34-_FireCAT">34. <a href="">FireCAT</a></h3><p>FireCAT (Firefox Catalog of Auditing exTensions) 是一个收集最有效最有用的应用程序安全审计和风险评估工具的列表(这些工具以Firefox插件形式发布的),FireCAT中没有收集的安全工具类型包 括:fuzzer,代理和应用程序扫描器.</p>
<h3 id="引用">引用</h3><p><a href="https://www.91ri.org/4441.html" target="_blank" rel="external">https://www.91ri.org/4441.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工欲善必先利其器，firefox一直是各位渗透师必备的利器，小编这里推荐34款firefox渗透测试辅助插件，其中包含渗透测试、信息收集、代理、加密解密等功能。</p>
<h3 id="1-_Firebug">1. <a href="https://addons.mozil]]>
    </summary>
    
      <category term="［安全,渗透,工具］" scheme="http://yoursite.com/tags/%EF%BC%BB%E5%AE%89%E5%85%A8-%E6%B8%97%E9%80%8F-%E5%B7%A5%E5%85%B7%EF%BC%BD/"/>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL 索引简介]]></title>
    <link href="http://yoursite.com/2015/09/29/MySQL-%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2015/09/29/MySQL-索引简介/</id>
    <published>2015-09-28T18:02:31.000Z</published>
    <updated>2015-10-10T09:12:07.000Z</updated>
    <content type="html"><![CDATA[<p>索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。索引是在存储引擎中实现的，而不是在服务器层中实现的。几种常见的索引类型：</p>
<h3 id="B-Tree类型的索引">B-Tree类型的索引</h3><ul>
<li>普通索引(Normal Indexes)—普通索引是最基本的索引而且没有任何限制(比如唯一性等限制)。普通索引可以包含重复的值。</li>
<li>唯一索引(Unique Indexes)—唯一索引和普通索引基本上是相同的。有一点不同的是：使用唯一索引的索引的列的所有值必须是唯一的，在该列中不能使用重复的值，但可以使用null。如果是组合索引，则列值的组合必须唯一。</li>
<li>主键索引(Primary keys)—它是一种特殊的唯一索引，不允许有空值。主键索引相当于“唯一索引+not null”。所有使用主键索引的列必须唯一并且不能为空。通常我们使用”auto_increment”来设置主键。 </li>
<li>全文索引(Full-text Indexes)—全文索引用在MySQL的全文搜索中。通常这种索引被用在搜索引擎类的应用中，用来从某个字段中检索特别的关键字。目前只有MyISAM引擎支持。</li>
</ul>
<p>B-Tree类型的索引可以用于表达式中列的比较，如&gt;、&gt;=、&lt;、&lt;=或BETWEEN运算符。这种类型的索引也可以用在LIKE、IN、IS NULL等的比较中。当然，在某些场景下，MySQL并不会使用索引，如NOT IN、IS NOT NULL,、LIKE ‘%sql%’ 等。</p>
<h3 id="空间索引(Spacial_Indexes)(R-tree)">空间索引(Spacial Indexes)(R-tree)</h3><p>只有MyISAM存储引擎才支持空间索引。它就像B-Tree索引一样，但是它并不仅仅遵循从做到右的顺序。空间索引仅仅被用在某些特殊的场景中，如MySQL GIS functions。</p>
<h3 id="哈希索引(Hash_Indexes)">哈希索引(Hash Indexes)</h3><p>hash就是一种（key=&gt;value）形式的键值对，哈希索引完全不同于B-Tree索引。哈希索引只能被用在相等比较中，如”=”和”!=”操作，而且速度非常快。目前只有Memory 存储引擎支持哈希索引。</p>
<h3 id="引用">引用</h3><p><a href="http://www.php101.cn/2014/08/14/MySQl%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">http://www.php101.cn/2014/08/14/MySQl%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/</a><br><a href="http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html" target="_blank" rel="external">http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html</a><br><a href="http://blog.csdn.net/dyllove98/article/details/9631303" target="_blank" rel="external">http://blog.csdn.net/dyllove98/article/details/9631303</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。索引是在存储引擎中实现的，而不是在服务器层中实现的。几种常见的索引类型：</p>
<h3 id="B-Tree类型的索引">B-Tree类型的索引</h3><ul>
<li>普通索引(Normal I]]>
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript 对象与 JOSON]]></title>
    <link href="http://yoursite.com/2015/09/28/javascript-%E5%AF%B9%E8%B1%A1%E4%B8%8E-JOSON/"/>
    <id>http://yoursite.com/2015/09/28/javascript-对象与-JOSON/</id>
    <published>2015-09-27T17:41:41.000Z</published>
    <updated>2015-10-10T09:13:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>JavaScript 对象与传统的面向对象中的对象几乎没有相似之处，传统的面向对象语言中，创建一个对象必须先有对象的模板：类，类中定义了对象的属性和操作这些属性的方法。通过实例化来构筑一个对象，然后使用对象间的协作来完成一项功能，通过功能的集合来完成整个工程。而Javascript中是没有类的概念的，借助JavaScript的动态性，我们完全可以创建一个空的对象(而不是类)，通过像对象动态的添加属性来完善对象的功能。 </p>
<p>JSON 即 JavaScript Object Notation 是一种轻量级数据交换格式，采用完全独立于语言的文本格式，非常适合于服务器与 JavaScript 的交互，当两个应用程序、或者两台服务器、或者两种语言之间进行“交流”时，他们都趋向于采用字符串。</p>
<p>JSON 是一种数据交换格式，像 XML 和 YAML 一样是一种在各种不同语言间传递结构化信息的方式。从另一方面来说，JavaScript 对象是 JavaScript 语言中的一种数据类型，就像 PHP 中的数组、C++ 中类和结构体。</p>
<h3 id="定义_JSON_与_JavaScript">定义 JSON 与 JavaScript</h3><p>在 JavaScript 程序中定义对象的时候，对象的属性名可以加双引号也可以不加双引号。如果属性名包含特殊字符(如!、if等)的时候，就必须加双引号。<br>在定义 JSON 的时候，属性名必须加双引号。</p>
<p>代码示例：</p>
<p>1.定义 JavaScript 对象</p>
<pre><code><span class="number">1.</span> var obj = {name: <span class="string">"woolong"</span>, <span class="string">"gender"</span>: <span class="string">"man"</span>}; <span class="preprocessor"># 两个属性可以加双引号也可以不加</span>
<span class="number">2.</span> var obj = {<span class="string">"!"</span>: <span class="string">"hello word"</span>}; <span class="preprocessor"># 属性名包含特殊字符时必须加双引号 </span>
</code></pre><p>2.定义 JSON 字符串</p>
<pre><code><span class="number">1.</span> var jsonStr = {<span class="string">"name"</span>: <span class="string">"woolong"</span>}; <span class="preprocessor"># 定义 JSON 时必须加双引号。</span>
</code></pre><h3 id="JavaScript_对象转换为_JSON">JavaScript 对象转换为 JSON</h3><p>我们可以使用 JavaScript 的内置函数将 JavaScript 对象转换为 JSON，这个函数就是 JSON.stringify()。</p>
<p>代码示例：</p>
<pre><code>1. var obj = {name: <span class="string">"woolong"</span>, <span class="keyword">gender</span>: <span class="string">"man"</span>};
2. var jsonObj = JSON.stringify(obj);
3. console.log(jsonObj); // 输出结果为：{<span class="string">"name"</span>: <span class="string">"woolong"</span>, <span class="string">"gender"</span>: <span class="string">"man"</span>}
</code></pre><p>在将 JavaScript 对象转换为 JSON 的时候，有一点是需要我们注意的：<br>如果对象中包含有值为函数和日期的属性，JSON 会忽略值为函数的属性，并将值为日期的属性转换为字符串。<br>代码示例：</p>
<pre><code><span class="number">1.</span> var obj = {
<span class="number">2.</span>             name: <span class="string">"woolong"</span>,
<span class="number">3.</span>             birthday: <span class="keyword">new</span> Date(),
<span class="number">4.</span>             action: function () {
<span class="number">5.</span>                     document.write(<span class="string">"wolf"</span>);
<span class="number">6.</span>             }
<span class="number">7.</span> };
<span class="number">8.</span> var jsonObj = JSON.stringify(obj);
<span class="number">9.</span> console.<span class="built_in">log</span>(jsonObj); <span class="comment">//输出结果为：{"name":"woolong","birthday":"2015-09-28T08:47:44.358Z"}</span>
</code></pre><h3 id="JavaScript_中解析_JSON">JavaScript 中解析 JSON</h3><p>在老版本的 JS 中，大家通常都使用 eval() 函数来解析 JSON，但是 ECMAScript5 给我们提供了一个解析 JSON 的新函数 JSON.parse()。<br>这个函数的使用方法比较简单，大家可以自行尝试。当对某个 JSON 字符串应用该函数以后，该 JSON 就被转换为 JavaScript 的对象，也就是说当用 typeof 运算符查看该函数的类型时，返回的值是 Object。<br>同样有一点需要注意的是，该函数是 ECMAScript5 以后才支持的，如果是旧版本的浏览器那么可能不支持该函数。解决的方法是加载一个实现该函数的 JS 文件，即 json2.js。如果使用的是 JQuery 框架，jQuery.parseJSON()，该函数调用了 JSON.parse() 方法。<br>关于使用 eval() 方法解析 JSON ，这个等深入学习后会记录下来。</p>
<h3 id="一个很重要的概念">一个很重要的概念</h3><p>作为一个前端菜鸟，经常听到别人说“JSON对象”，但是其实并没有“JSON对象”这个概念，JSON真正的表现形式是字符串。</p>
<h3 id="引用">引用</h3><p><a href="http://www.php101.cn/2014/08/12/javascript%E5%AF%B9%E8%B1%A1%E4%B8%8EJSON/" target="_blank" rel="external">http://www.php101.cn/2014/08/12/javascript%E5%AF%B9%E8%B1%A1%E4%B8%8EJSON/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="简介">简介</h3><p>JavaScript 对象与传统的面向对象中的对象几乎没有相似之处，传统的面向对象语言中，创建一个对象必须先有对象的模板：类，类中定义了对象的属性和操作这些属性的方法。通过实例化来构筑一个对象，然后使用对象间的协作来完成一项功能，通过功]]>
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 创建分支]]></title>
    <link href="http://yoursite.com/2015/09/25/Git-%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF/"/>
    <id>http://yoursite.com/2015/09/25/Git-创建分支/</id>
    <published>2015-09-25T08:12:20.000Z</published>
    <updated>2015-10-14T09:52:26.000Z</updated>
    <content type="html"><![CDATA[<p>使用 Git 本地创建分支</p>
<h5 id="1-_查看分支">1. 查看分支</h5><pre><code>git branch
/<span class="keyword">*</span><span class="keyword">*</span> 这里会列出所有本地的分支，查看原称分支 git branch -a <span class="keyword">*</span><span class="keyword">*</span>/
</code></pre><h5 id="2-_创建本地分支">2. 创建本地分支</h5><pre><code>git checkout -b test1
/<span class="keyword">*</span><span class="keyword">*</span> git checktout 也是切换分支<span class="keyword">*</span><span class="keyword">*</span>/
</code></pre><h5 id="3-_提交到远程">3. 提交到远程</h5><pre><code>上一步虽然创建了分支，但是远程还没有该分支，需要提交一次
</code></pre><h5 id="4-本地分支与云端库比较">4.本地分支与云端库比较</h5><pre><code><span class="comment">// 获取远端库最新信息</span>
git fetch origin
<span class="comment">// 做比较</span>
git diff 本地分支名 origin 远端分支名
<span class="comment">// 有时间改动文件比较多，只想显示文件</span>
git diff 本地分支名 origin 远端分支名 --state
</code></pre><p>备注下来，以便查阅，后续会有改动。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用 Git 本地创建分支</p>
<h5 id="1-_查看分支">1. 查看分支</h5><pre><code>git branch
/<span class="keyword">*</span><span class="keyword">*</span> 这里会列出所]]>
    </summary>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="工具，diff" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%EF%BC%8Cdiff/"/>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP 缓存技术]]></title>
    <link href="http://yoursite.com/2015/09/22/PHP-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2015/09/22/PHP-缓存技术/</id>
    <published>2015-09-22T09:23:35.000Z</published>
    <updated>2015-09-22T16:12:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_数据缓存">1. 数据缓存</h3><p>主要是指数据库查询结果的缓存，每次访问页面的时候先检测响应的缓存数据是否存在，如果不存在，就连接数据库查询数据，并把查询结果保存到文件中，以后同样的查询结果就直接从缓存中获取。用空间（硬盘）换速度是关键点。</p>
<h3 id="2-_内存缓存">2. 内存缓存</h3><p>Memcached是高性能的分布式内存缓存服务器。一般的使用目的是通过缓存数据库查询结果，减少数据库的访问次数，以提高动态 WEB 的访问速度、减少数据库负载。</p>
<p>它是将需要缓存的信息，缓存到系统内存中，需要获取信息中，直接到内存中取，比较常用的方式是 key-&gt;value 方式。</p>
<h3 id="3-_页面缓存">3. 页面缓存</h3><p>访问 WEB 页面时，先检测相应的缓存页面文件是否存在，如果不存在，则连接数据库，查询数据，显示页面并同时生成缓存页面文件，下次访问的时候缓存的页面文件就发挥作用了。页面缓存有一下几种方式。</p>
<h6 id="时间触发缓存">时间触发缓存</h6><p>检查文件是否存在并且缓存时间是否过期,如果文件修改的时间没有过期时间，那么就用缓存，否则更新缓存。</p>
<h6 id="内容出发缓存">内容出发缓存</h6><p>当页面数据有更新时，更改数据库的同时也强制更新缓存。</p>
<h6 id="页面部分缓存">页面部分缓存</h6><p>将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示；可以使用类似于 ob_get_contents 的方式实现，也可以利用类似 ESI 之类的页面片段缓存策略，使其用来做动态页面中相对静态的片段部分的缓存。该种方式可以用于如商城中的商品页；</p>
<h6 id="全页面静态化缓存">全页面静态化缓存</h6><p>直接生成HTML或XML等文本文件，有更新的时候重生成一次，而不会去走php服务器解析的流程，适合于不太变化的页面。</p>
<h3 id="4-_PHP_的OPCode（缓冲器、加速器）缓存">4. PHP 的OPCode（缓冲器、加速器）缓存</h3><p>有eAccelerator， APC， PHPA，XCache，这个没有太深的研究，暂不多说。</p>
<h3 id="5-_Apache_缓存模块">5.  Apache 缓存模块</h3><p>Apache 安装完以后，是不允许被 cache 的。如果外接了cache 或 squid 服务器要求进行 web 加速的话，就需要在 htttpd.conf 里进行设置，当然前提是在安装 Apache 的时候要激活 mod_cache 的模块。<br>安装 Apache 时：./configure –enable-cache –enable-disk-cache –enable-mem-cache</p>
<h3 id="6-_基于反向代理的_WEB_缓存">6.  基于反向代理的 WEB 缓存</h3><p>如 Nginx ，SQUID ，mod_proxy ( apache2 以上又分为 mod_proxy 和 mod_cache )</p>
<h3 id="7-_DNS_轮询">7. DNS 轮询</h3><p>大多域名注册商都支持多条A记录的解析，其实这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，逐一分配到不同的IP上，这样就完成了简单的负载均衡。更深层次的暂未研究。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_数据缓存">1. 数据缓存</h3><p>主要是指数据库查询结果的缓存，每次访问页面的时候先检测响应的缓存数据是否存在，如果不存在，就连接数据库查询数据，并把查询结果保存到文件中，以后同样的查询结果就直接从缓存中获取。用空间（硬盘）换速度是关键点。</p>
]]>
    </summary>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP的运行模式（理论）]]></title>
    <link href="http://yoursite.com/2015/09/21/PHP%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/09/21/PHP的运行模式/</id>
    <published>2015-09-21T08:52:19.000Z</published>
    <updated>2015-09-22T09:30:51.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍几种运行模式：CGI 通用网关接口(Common Gateway Interface)、FAST-CGI 常驻性 CGI(long-live CGI)、CLI 命令行运行(Command Line Interface)。</p>
<h3 id="1-_CGI_通用网关接口_(Common_Gateway_Interface)">1. CGI 通用网关接口 (Common Gateway Interface)</h3><p>CGI是一段程序，就像桥梁一样连接着 HTML 和 WEB 服务器，它把 HTML 接收到的指令传递给服务器的执行程序，在把服务器的运行结果返回给 HTML 。CGI 的跨平台性能非常的好，几乎可以在所有的操作系统上实现。但是 CGI 已经是比较老的模式了，最近几年很少用，被FAST－CGI替代。</p>
<p>当有一个请求时，首先要创建一个CGI子进程，然后处理请求，处理完后在结束该子进程，这就是 fork－and－execute 模式。如果用户的请iu数量非常多时，会产生大量的CGI子进程，有多少个请求就会产生多少个子进程，这样会大量挤占系统的资源如 CPU、内存等，这是造成 CGI 性能低下的主要原因。</p>
<h3 id="2-_FAST-CGI_常驻性_CGI(long-live_CGI)">2. FAST-CGI 常驻性 CGI(long-live CGI)</h3><p>fast-cgi 是cgi的升级版本，FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一 次 (这是 CGI 最为人诟病的 fork-and-execute 模式)。PHP使用PHP-FPM(FastCGI Process Manager)，全称PHP FastCGI进程管理器进行管理。</p>
<p>FastCGI的工作原理：</p>
<ol>
<li><p>Web Server启动时载入FastCGI进程管理器(IIS ISAPI或Apache Module)</p>
</li>
<li><p>FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自Web Server的连接。</p>
</li>
<li><p>当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi 。</p>
</li>
<li><p>FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server 。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器 (运行在Web Server中)的下一个连接。 在 CGI 模式中，php-cgi 在此便退出了。</p>
</li>
</ol>
<p>在上述情况中，你可以想象 CGI 通常有多慢。每一个 Web 请求 PHP 都必须重新解析 php.ini、重新载入全部扩展并重初始化全部数据结构。使用 FastCGI ，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接 (Persistent database connection) 可以工作。</p>
<p>Fastcgi的优点：</p>
<ol>
<li><p>从稳定性上看, FastCGI 是以独立的进程池来运行 CGI ,单独一个进程死掉,系统可以很轻易的丢弃该进程,然后重新分配新的进程来运行逻辑。</p>
</li>
<li><p>从安全性上看, FastCGI 支持分布式运算。FastCGI 和宿主的 server 完全独立, FastCGI 挂掉的话不会影响宿主 server。</p>
</li>
<li><p>从性能上看, FastCGI 把动态逻辑的处理从 server 中分离出来, 大负荷的 IO 处理还是留给宿主 server, 宿主 server 只进行 IO 处理。对于一个普通的动态网页来说, 逻辑处理可能只有一小部分,FastCGI 进程暂用的系统资源会非常少，配合静态缓存页面，性能会得到很大的提升。</p>
</li>
</ol>
<p>Fastcgi的优点：</p>
<ul>
<li>从实际使用来看，用 FastCGI 模式更适合生产环境的服务器。但对于开发用机器来说就不太合适。因为当使用 Zend Studio 调试程序时，由于 FastCGI 会认为 PHP 进程超时，从而在页面返回 500错误。</li>
<li>目前的 FastCGI 和 Server 沟通还不够智能，一个 FastCGI 进程如果执行时间过长会被当成是死进程杀掉重起，这样在处理长时间任务的时候很麻烦，这样做也使得 FastCGI 无法允许联机调试。因为是多进程，所以比 CGI 多线程消耗更多的服务器内存，PHP-CGI 解释器每进程消耗 7 至 25 兆内存，将这个数字乘以 50 或 100 就是很大的内存数。</li>
</ul>
<h3 id="3-_CLI_命令行运行(Command_Line_Interface)">3. CLI 命令行运行(Command Line Interface)</h3><p>它是 PHP 的命令行运行模式，大家经常使用它，但是可能并没有注意到（命令行中使用 php -v 等，有兴趣的可以输入 php -h 深入研究）</p>
<p>优点：</p>
<ol>
<li><p>使用多进程，子进程结束以后，内核会负责回收资源。</p>
</li>
<li><p>使用多进程，子进程异常退出不会导致整个进程 Thread 退出，父进程还有机会重建流程；</p>
</li>
<li><p>一个常驻主进程，只负责任务分发，逻辑更清楚。</p>
</li>
</ol>
<h3 id="总结">总结</h3><p>每种运行模式都有自己的优缺点，没有绝对的好与坏，主要是看运行的环境。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍几种运行模式：CGI 通用网关接口(Common Gateway Interface)、FAST-CGI 常驻性 CGI(long-live CGI)、CLI 命令行运行(Command Line Interface)。</p>
<h3 id="1-_CGI_通]]>
    </summary>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="运行模式" scheme="http://yoursite.com/tags/%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[完全理解 SQL 之 SELECT 句式]]></title>
    <link href="http://yoursite.com/2015/09/20/10-steps-to-learn-SQL/"/>
    <id>http://yoursite.com/2015/09/20/10-steps-to-learn-SQL/</id>
    <published>2015-09-19T16:47:18.000Z</published>
    <updated>2015-09-19T17:28:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1-SQL_一种声明式语言">1.SQL 一种声明式语言</h1><p>SQL是一种声“明式”语言。SQL语言是为计算机声明了一个你想从数据库中获得结果的范例（可以理解为SQL语句），而不是告诉计算机如何得到SQL查询的结果。</p>
<p>如果SQL语言这么简单，那么人么为什么“闻SQL色变”？主要原因是：潜意识中是按照编程命令式编程思维方式思考问题。就好比这样：程序执行顺训，从上到下，第一个函数执行完后在执行下一个。这种命令式编程的思维惯式。</p>
<h1 id="2-SQL_语法的执行顺序">2.SQL 语法的执行顺序</h1><p>SQL语句有一个非常困惑大家的特性：SQL语句的执行顺训跟SQL语句的语法顺训并不一致。SQL语句的执行顺序是：</p>
<pre><code>* <span class="keyword">FROM</span>
* <span class="keyword">WHERE</span>
* <span class="keyword">GROUP</span> <span class="keyword">BY</span>
* HAVING
* <span class="keyword">SELECT</span>
* <span class="keyword">DISTINCT</span>
* <span class="keyword">UNION</span>
* <span class="keyword">ORDER</span> <span class="keyword">BY</span>
</code></pre><p>这里我们需要注意三个地方</p>
<pre><code><span class="number">1</span>. <span class="keyword">FROM</span> 才是 SQL 语句执行的第一步，并非 <span class="keyword">SELECT</span>。数据库在执行语句第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。
<span class="number">2</span>. <span class="keyword">SELECT</span> 是在大部分语句执行后才执行的，严格的说是在 <span class="keyword">FROM</span> 和 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 之后执行的。理解这一点非常重要，这就是你不能在 <span class="keyword">WHERE</span> 中使用在 <span class="keyword">SELECT</span> 中设别名的字段作为判断条件的原因。
<span class="number">3</span>. 无论在语法还是执行顺序上，<span class="keyword">UNION</span> 总是排在 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 之前。很多人认为每个 <span class="keyword">UNION</span> 段都能使用 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序，但是根据 SQL 语言标准和各个数据库 SQL 的执行差异来看，这并不是真的。尽管某些数据库允许 SQL 语句对子查询或者派生表进行排序，但是这并不说明这个排序在 <span class="keyword">UNION</span> 操作过后仍保持排序的顺序。
 注意：并非所有的数据库对 SQL 语句使用相同的解析方式。如 MySQL、PostgreSQL 和 SQLite 中就不会按照第二点执行。
</code></pre><h3 id="我们学到了什么">我们学到了什么</h3><p>既然并不是所有的数据库都是按照上面方式执行，那我们学到了什么？我们的收获是永远要记得：SQL 语句的语法顺序和其执行顺序并不一致，这样我们就能避免一般性的错误。如果你能记住 SQL 语法顺序和执行顺序的差异，那你就能很容易的理解一些常见的 SQL 问题。</p>
<p>当然，如果一种语言被设计成语法顺序直接反应其语句的执行顺序，那么这种语言对程序员是十分友好的，如：微软的 LINO 语言。</p>
<h1 id="3-SQL_语言的核心是对表的引用（table_references）">3.SQL 语言的核心是对表的引用（table references）</h1><p>由于 SQL 语句语法顺序和执行顺序的不同，很多人认为 SELECT 中的字段信息是 SQL 语句的核心。但是真正的核心在于对表的引用。</p>
<p>根据 SQL 标准，FROM 语句被定义为：</p>
<pre><code><span class="tag">&lt;<span class="title">from</span> <span class="attribute">clause</span> &gt;</span> ::= FROM <span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> [ { <span class="tag">&lt;<span class="title">comma</span>&gt;</span> <span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> }... ]
</code></pre><p>FROM 语句的输出”是一张联合表，来自于所有引用的表在某一维度上的联合。我们来慢慢分析：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>上面这句 FROM 语句的输出是一张联合表，联合了表 a 和表 b 。如果 a 表有三个字段， b 表有 5 个字段，那么这个“输出表”就有 8 （ =5+3）个字段。</p>
<p>这个联合表里的数据是 a＊b，即 a 和 b 的笛卡尔积。换句话说，也就是 a 表中的每一条数据都要跟 b 表中的每一条数据配对。如果 a 表有3 条数据， b 表有 5 条数据，那么联合表就会有 15 （ =5＊3）条数据。</p>
<p>FROM 输出的结果被 WHERE 语句筛选后要经过 GROUP BY 语句处理，从而形成新的输出结果。我们后面还会再讨论这方面问题。</p>
<p>如果我们从集合论（关系代数）的角度来看，一张数据库的表就是一组数据元的关系，而每个 SQL 语句会改变一种或数种关系，从而产生出新的数据元的关系（即产生新的表）。</p>
<p>我们学到了什么？</p>
<p> 思考问题的时候从表的角度来思考问题，这样很容易理解数据如何在 SQL 语句的“流水线”上进行了什么样的变动。</p>
<h1 id="4-灵活引用表能使_SQL_语句变得更强大">4.灵活引用表能使 SQL 语句变得更强大</h1><p>灵活引用表能使 SQL 语句变得更强大。一个简单的例子就是 JOIN 的使用。严格的说 JOIN 语句并非是 SELECT 中的一部分，而是一种特殊的表引用语句。 SQL 语言标准中表的连接定义如下：</p>
<pre><code><span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> ::=
    <span class="tag">&lt;<span class="title">table</span> <span class="attribute">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">derived</span> <span class="attribute">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">joined</span> <span class="attribute">table</span>&gt;</span>
</code></pre><p>就拿之前的例子来说：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>a 可能输如下表的连接：</p>
<pre><code><span class="label">a1</span> JOIN <span class="literal">a2</span> ON <span class="literal">a1</span>.id = <span class="literal">a2</span>.id
</code></pre><p>将它放到之前的例子中就变成了：</p>
<pre><code><span class="label">FROM</span> <span class="literal">a1</span> JOIN <span class="literal">a2</span> ON <span class="literal">a1</span>.id = <span class="literal">a2</span>.id, <span class="keyword">b</span>
</code></pre><p>尽管将一个连接表用逗号跟另一张表联合在一起并不是常用作法，但是你的确可以这么做。结果就是，最终输出的表就有了 a1+a2+b 个字段了。</p>
<p>在 SQL 语句中派生表的应用甚至比表连接更加强大，下面我们就要讲到表连接。</p>
<h3 id="我们学到了什么？">我们学到了什么？</h3><p>思考问题时，要从表引用的角度出发，这样就很容易理解数据是怎样被 SQL 语句处理的，并且能够帮助你理解那些复杂的表引用是做什么的。</p>
<p>更重要的是，要理解 JOIN 是构建连接表的关键词，并不是 SELECT 语句的一部分。有一些数据库允许在 INSERT 、 UPDATE 、 DELETE 中使用 JOIN 。</p>
<h1 id="5-SQL_语句中推荐使用表连接">5.SQL 语句中推荐使用表连接</h1><p>我们先看看刚刚这句话：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>高级 SQL 程序员也许学会给你忠告：尽量不要使用逗号来代替 JOIN 进行表的连接，这样会提高你的 SQL 语句的可读性，并且可以避免一些错误。</p>
<p>利用逗号来简化 SQL 语句有时候会造成思维上的混乱，想一下下面的语句：</p>
<pre><code>FROM <span class="tag">a</span>, <span class="tag">b</span>, c, d, e, f, g, h
WHERE <span class="tag">a</span><span class="class">.a1</span> = <span class="tag">b</span><span class="class">.bx</span>
AND <span class="tag">a</span><span class="class">.a2</span> = c<span class="class">.c1</span>
AND d<span class="class">.d1</span> = <span class="tag">b</span><span class="class">.bc</span>
-- etc...
</code></pre><p>我们不难看出使用 JOIN 语句的好处在于：</p>
<pre><code><span class="bullet">* </span>安全。 JOIN 和要连接的表离得非常近，这样就能避免错误。
<span class="bullet">* </span>更多连接的方式，JOIN 语句能去区分出来外连接和内连接等。
</code></pre><h3 id="我们学到了什么？-1">我们学到了什么？</h3><p>记着要尽量使用 JOIN 进行表的连接，永远不要在 FROM 后面使用逗号连接表。</p>
<h1 id="6-SQL_语句中不同的连接操作">6.SQL 语句中不同的连接操作</h1><p>SQL 语句中，表连接的方式从根本上分为五种：</p>
<pre><code><span class="bullet">* </span>EQUI JOIN
<span class="bullet">* </span>SEMI JOIN
<span class="bullet">* </span>ANTI JOIN
<span class="bullet">* </span>CROSS JOIN
<span class="bullet">* </span>DIVISION
</code></pre><h3 id="EQUI_JOIN">EQUI JOIN</h3><p>这是一种最普通的 JOIN 操作，它包含两种连接方式：</p>
<pre><code>* INNER <span class="built_in">JOIN</span>（或者是 <span class="built_in">JOIN</span> ）
* OUTER <span class="built_in">JOIN</span>（包括： <span class="built_in">LEFT</span> 、 <span class="built_in">RIGHT</span>、 FULL OUTER <span class="built_in">JOIN</span>）
</code></pre><p>用例子最容易说明其中区别：</p>
<pre><code>-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books.
</span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.
</span>-<span class="ruby">- authors without books are <span class="constant">NOT</span> included
</span>author JOIN book ON author.id = book.author_id

-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books
</span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.
</span>-<span class="ruby">- ... <span class="constant">OR</span> there is an <span class="string">"empty"</span> record <span class="keyword">for</span> authors without books
</span>-<span class="ruby">- (<span class="string">"empty"</span> meaning that all book columns are <span class="constant">NULL</span>)
</span>author LEFT OUTER JOIN book ON author.id = book.author_id
</code></pre><h3 id="SEMI_JOIN">SEMI JOIN</h3><p>这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。“ SEMI ”在拉丁文中是“半”的意思。这种连接方式是只连接目标表的一部分。这是什么意思呢？再想一下关于作者和书名的连接。我们想象一下这样的情况：我们不需要作者 / 书名这样的组合，只是需要那些在书名表中的书的作者信息。那我们就能这么写：</p>
<pre><code>-- <span class="keyword">Using</span> <span class="keyword">IN</span>
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> author.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)

-- <span class="keyword">Using</span> EXISTS
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)
</code></pre><p>尽管没有严格的规定说明你何时应该使用 IN ，何时应该使用 EXISTS ，但是这些事情你还是应该知道的：</p>
<pre><code><span class="bullet">* </span>IN比 EXISTS 的可读性更好
<span class="bullet">* </span>EXISTS 比IN 的表达性更好（更适合复杂的语句）
<span class="bullet">* </span>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）
</code></pre><p>因为使用 INNER JOIN 也能得到书名表中书所对应的作者信息，所以很多初学者机会认为可以通过 DISTINCT 进行去重，然后将 SEMI JOIN 语句写成这样：</p>
<pre><code><span class="comment">-- Find only those authors who also have books</span>
<span class="operator">SELECT <span class="keyword">DISTINCT</span> first_name, last_name
<span class="keyword">FROM</span> author
<span class="keyword">JOIN</span> book <span class="keyword">ON</span> author.<span class="keyword">id</span> = book.author_id</span>
</code></pre><p>这是一种很糟糕的写法，原因如下：</p>
<pre><code><span class="bullet">* </span>SQL 语句性能低下：因为去重操作（ DISTINCT ）需要数据库重复从硬盘中读取数据到内存中。
<span class="bullet">* </span>这么写并非完全正确：尽管也许现在这么写不会出现问题，但是随着 SQL 语句变得越来越复杂，你想要去重得到正确的结果就变得十分困难。
</code></pre><p>更多的关于滥用 DISTINCT 的危害可以参考这篇博文</p>
<p>（<a href="http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/" target="_blank" rel="external">http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/</a>）。</p>
<h3 id="ANTI_JOIN">ANTI JOIN</h3><p>这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接。举个例子来说，我们列出书名表里没有书的作者：</p>
<pre><code>-- <span class="keyword">Using</span> <span class="keyword">IN</span>
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> author.id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)

-- <span class="keyword">Using</span> EXISTS
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)
</code></pre><p>关于性能、可读性、表达性等特性也完全可以参考 SEMI JOIN。</p>
<p>这篇博文介绍了在使用 NOT IN 时遇到 NULL 应该怎么办，因为有一点背离本篇主题，就不详细介绍，有兴趣的同学可以读一下</p>
<p>（<a href="http://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/" target="_blank" rel="external">http://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/</a>）。</p>
<h3 id="CROSS_JOIN">CROSS JOIN</h3><p>这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法。在实际的应用中，很少有地方能用到 CROSS JOIN，但是一旦用上了，你就可以用这样的 SQL语句表达：</p>
<pre><code>-- Combine <span class="keyword">every</span> author with <span class="keyword">every</span> book
author CROSS <span class="keyword">JOIN</span> book
</code></pre><h3 id="DIVISION">DIVISION</h3><p>DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来，介于这是一个新手指南，解释 DIVISION 已经超出了我们的目的。但是有兴趣的同学还是可以来看看这三篇文章</p>
<p>（<a href="http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/" target="_blank" rel="external">http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/</a>）</p>
<p>（<a href="http://en.wikipedia.org/wiki/Relational_algebra#Division" target="_blank" rel="external">http://en.wikipedia.org/wiki/Relational_algebra#Division</a>）</p>
<p>（<a href="https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/" target="_blank" rel="external">https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a>）。</p>
<p>推荐阅读 →_→ <a href="http://blog.jobbole.com/40443/" target="_blank" rel="external">《画图解释SQL联合语句》</a></p>
<h3 id="我们学到了什么？-2">我们学到了什么？</h3><p>学到了很多！让我们在脑海中再回想一下。 SQL 是对表的引用， JOIN 则是一种引用表的复杂方式。但是 SQL 语言的表达方式和实际我们所需要的逻辑关系之间是有区别的，并非所有的逻辑关系都能找到对应的 JOIN 操作，所以这就要我们在平时多积累和学习关系逻辑，这样你就能在以后编写 SQL 语句中选择适当的 JOIN 操作了。</p>
<h1 id="7-SQL_中如同变量的派生表">7.SQL 中如同变量的派生表</h1><p>在这之前，我们学习到过 SQL 是一种声明性的语言，并且 SQL 语句中不能包含变量。但是你能写出类似于变量的语句，这些就叫做派生表：</p>
<p>说白了，所谓的派生表就是在括号之中的子查询：</p>
<pre><code>-- A derived table
<span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author)
</code></pre><p>需要注意的是有些时候我们可以给派生表定义一个相关名（即我们所说的别名）。</p>
<pre><code>-- A derived table <span class="keyword">with</span> an <span class="keyword">alias</span>
<span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author) a
</code></pre><p>派生表可以有效的避免由于 SQL 逻辑而产生的问题。举例来说：如果你想重用一个用 SELECT 和 WHERE 语句查询出的结果，这样写就可以（以 Oracle 为例）：</p>
<pre><code>-- <span class="keyword">Get</span> authors<span class="comment">' first and last names, and their age in days</span>
<span class="keyword">SELECT</span> first_name, last_name, age
<span class="keyword">FROM</span> (
  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age
  <span class="keyword">FROM</span> author
)
-- <span class="keyword">If</span> the age <span class="keyword">is</span> greater than <span class="number">10000</span> days
<span class="keyword">WHERE</span> age &gt; <span class="number">10000</span>
</code></pre><p>需要我们注意的是：在有些数据库，以及 SQL ： 1990 标准中，派生表被归为下一级——通用表语句（ common table experssion）。这就允许你在一个 SELECT 语句中对派生表多次重用。上面的例子就（几乎）等价于下面的语句：</p>
<pre><code><span class="keyword">WITH</span> a <span class="keyword">AS</span> (
  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age
  <span class="keyword">FROM</span> author
)
<span class="keyword">SELECT</span> *
<span class="keyword">FROM</span> a
<span class="keyword">WHERE</span> age &gt; <span class="number">10000</span>
</code></pre><p>当然了，你也可以给“ a ”创建一个单独的视图，这样你就可以在更广泛的范围内重用这个派生表了。更多信息可以阅读下面的文章（<a href="http://en.wikipedia.org/wiki/View_%28SQL%29" target="_blank" rel="external">http://en.wikipedia.org/wiki/View_%28SQL%29</a>）。</p>
<h3 id="我们学到了什么？-3">我们学到了什么？</h3><p>我们反复强调，大体上来说 SQL 语句就是对表的引用，而并非对字段的引用。要好好利用这一点，不要害怕使用派生表或者其他更复杂的语句。</p>
<h1 id="8-SQL_语句中_GROUP_BY_是对表的引用进行的操作">8.SQL 语句中 GROUP BY 是对表的引用进行的操作</h1><p>让我们再回想一下之前的 FROM 语句：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>现在，我们将 GROUP BY 应用到上面的语句中：</p>
<pre><code>GROUP BY A<span class="class">.x</span>, A<span class="class">.y</span>, B.z
</code></pre><p>上面语句的结果就是产生出了一个包含三个字段的新的表的引用。我们来仔细理解一下这句话：当你应用 GROUP BY 的时候， SELECT 后没有使用聚合函数的列，都要出现在 GROUP BY 后面。</p>
<p>需要注意的是：其他字段能够使用聚合函数：</p>
<pre><code>SELECT A<span class="class">.x</span>, A<span class="class">.y</span>, <span class="function"><span class="title">SUM</span><span class="params">(A.z)</span></span>
FROM A
GROUP BY A<span class="class">.x</span>, A.y
</code></pre><p>还有一点值得留意的是： MySQL 并不坚持这个标准，这的确是令人很困惑的地方。但是不要被 MySQL 所迷惑。 GROUP BY 改变了对表引用的方式。你可以像这样既在 SELECT 中引用某一字段，也在 GROUP BY 中对其进行分组。</p>
<h3 id="我们学到了什么？-4">我们学到了什么？</h3><p>GROUP BY，再次强调一次，是在表的引用上进行了操作，将其转换为一种新的引用方式。</p>
<h1 id="9-SQL_语句中的_SELECT_实质上是对关系的映射">9.SQL 语句中的 SELECT 实质上是对关系的映射</h1><p>我个人比较喜欢“映射”这个词，尤其是把它用在关系代数上。一旦你建立起来了表的引用，经过修改、变形，你能够一步一步的将其映射到另一个模型中。 SELECT 语句就像一个“投影仪”，我们可以将其理解成一个将源表中的数据按照一定的逻辑转换成目标表数据的函数。</p>
<p>通过 SELECT语句，你能对每一个字段进行操作，通过复杂的表达式生成所需要的数据。</p>
<p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条：</p>
<pre><code><span class="number">1.</span> 你仅能够使用那些能通过表引用而得来的字段；
<span class="number">2.</span> 如果你有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句，你只能够使用 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句后面的字段或者聚合函数；
<span class="number">3.</span> 当你的语句中没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 的时候，可以使用开窗函数代替聚合函数；
<span class="number">4.</span> 当你的语句中没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 的时候，你不能同时使用聚合函数和其它函数；
<span class="number">5.</span> 有一些方法可以将普通函数封装在聚合函数中；
<span class="number">6.</span> ……
</code></pre><p>一些更复杂的规则多到足够写出另一篇文章了。比如：为何你不能在一个没有 GROUP BY 的 SELECT 语句中同时使用普通函数和聚合函数？（上面的第 4 条）</p>
<p>原因如下：</p>
<pre><code><span class="number">1</span>. 凭直觉，这种做法从逻辑上就讲不通。
<span class="number">2</span>. 如果直觉不能够说服你，那么语法肯定能。 SQL : <span class="number">1999</span> 标准引入了 GROUPING SETS，SQL： <span class="number">2003</span> 标准引入了 <span class="keyword">group</span> sets : <span class="keyword">GROUP</span> <span class="keyword">BY</span>() 。无论什么时候，只要你的语句中出现了聚合函数，而且并没有明确的 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句，这时一个不明确的、空的 GROUPING <span class="keyword">SET</span> 就会被应用到这段 SQL 中。因此，原始的逻辑顺序的规则就被打破了，映射（即 <span class="keyword">SELECT</span> ）关系首先会影响到逻辑关系，其次就是语法关系。（译者注：这段话原文就比较艰涩，可以简单理解如下：在既有聚合函数又有普通函数的 SQL 语句中，如果没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 进行分组，SQL 语句默认视整张表为一个分组，当聚合函数对某一字段进行聚合统计的时候，引用的表中的每一条 <span class="keyword">record</span> 就失去了意义，全部的数据都聚合为一个统计值，你此时对每一条 <span class="keyword">record</span> 使用其它函数是没有意义的）。
</code></pre><p>糊涂了？是的，我也是。我们再回过头来看点浅显的东西吧。</p>
<h3 id="我们学到了什么？-5">我们学到了什么？</h3><p>SELECT 语句可能是 SQL 语句中最难的部分了，尽管他看上去很简单。其他语句的作用其实就是对表的不同形式的引用。而 SELECT 语句则把这些引用整合在了一起，通过逻辑规则将源表映射到目标表，而且这个过程是可逆的，我们可以清楚的知道目标表的数据是怎么来的。</p>
<p>想要学习好 SQL 语言，就要在使用 SELECT 语句之前弄懂其他的语句，虽然 SELECT 是语法结构中的第一个关键词，但它应该是我们最后一个掌握的。</p>
<h1 id="10-SQL_语句中的几个简单的关键词：DISTINCT，UNION，ORDER_BY_和_OFFSET">10.SQL 语句中的几个简单的关键词：DISTINCT，UNION，ORDER BY 和 OFFSET</h1><p>在学习完复杂的 SELECT 豫剧之后，我们再来看点简单的东西：</p>
<pre><code>* 集合运算（ <span class="keyword">DISTINCT</span> 和 <span class="keyword">UNION</span> ）
* 排序运算（ <span class="keyword">ORDER</span> <span class="keyword">BY</span>，OFFSET…FETCH）
</code></pre><h3 id="集合运算（_set_operation）：">集合运算（ set operation）：</h3><p>集合运算主要操作在于集合上，事实上指的就是对表的一种操作。从概念上来说，他们很好理解：</p>
<pre><code><span class="bullet">* </span>DISTINCT 在映射之后对数据进行去重
<span class="bullet">* </span>UNION 将两个子查询拼接起来并去重
<span class="bullet">* </span>UNION ALL 将两个子查询拼接起来但不去重
<span class="bullet">* </span>EXCEPT 将第二个字查询中的结果从第一个子查询中去掉
<span class="bullet">* </span>INTERSECT 保留两个子查询中都有的结果并去重
</code></pre><h3 id="排序运算（_ordering_operation）：">排序运算（ ordering operation）：</h3><p>排序运算跟逻辑关系无关。这是一个 SQL 特有的功能。排序运算不仅在 SQL 语句的最后，而且在 SQL 语句运行的过程中也是最后执行的。使用 ORDER BY 和 OFFSET…FETCH 是保证数据能够按照顺序排列的最有效的方式。其他所有的排序方式都有一定随机性，尽管它们得到的排序结果是可重现的。</p>
<p>OFFSET…SET是一个没有统一确定语法的语句，不同的数据库有不同的表达方式，如 MySQL 和 PostgreSQL 的 LIMIT…OFFSET、SQL Server 和 Sybase 的 TOP…START AT 等。具体关于 OFFSET..FETCH 的不同语法可以参考这篇文章<br>（<a href="http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/" target="_blank" rel="external">http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/</a>）。</p>
<p>让我们在工作中尽情的使用 SQL！</p>
<p>正如其他语言一样，想要学好 SQL 语言就要大量的练习。上面的 10 个简单的步骤能够帮助你对你每天所写的 SQL 语句有更好的理解。另一方面来讲，从平时常见的错误中也能积累到很多经验。</p>
<p>基本参考<a href="http://blog.jobbole.com/55086/" target="_blank" rel="external">十步完全理解SQL</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-SQL_一种声明式语言">1.SQL 一种声明式语言</h1><p>SQL是一种声“明式”语言。SQL语言是为计算机声明了一个你想从数据库中获得结果的范例（可以理解为SQL语句），而不是告诉计算机如何得到SQL查询的结果。</p>
<p>如果SQL语言这么简单]]>
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <link href="http://yoursite.com/2015/09/12/hello-world/"/>
    <id>http://yoursite.com/2015/09/12/hello-world/</id>
    <published>2015-09-12T15:55:08.000Z</published>
    <updated>2015-09-12T15:55:08.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to My Notes! This is my very first post. 开始写博客了，一直以来想把自己的学习的东西记录下来，可能比较懒吧，最近才开始有了真实的行动来完成。</p>
<h2 id="构建博客的框架">构建博客的框架</h2><pre><code>结构采用比较流行的 hexo，之所以选择他是因为他方便、快。
博客主题采用的是当前星最高的也是我比较喜欢的主题 <span class="keyword">next</span>。
</code></pre><h2 id="博客的主要内容">博客的主要内容</h2><pre><code>主要记录自己在工作学习中用的知识点，以备平时需要时查询，也希望大家来交流下经验。
</code></pre><h2 id="后记">后记</h2><pre><code>比自己聪明的人还在努力的学习，我有什么资格来放弃学习！
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to My Notes! This is my very first post. 开始写博客了，一直以来想把自己的学习的东西记录下来，可能比较懒吧，最近才开始有了真实的行动来完成。</p>
<h2 id="构建博客的框架">构建博客的框架</h2><pre>]]>
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
