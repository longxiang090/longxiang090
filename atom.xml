<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[WooLong's Notes]]></title>
  <subtitle><![CDATA[生命不息，奋斗不止]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-09-19T17:28:22.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[WooLong]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[完全理解 SQL 之 SELECT 句式]]></title>
    <link href="http://yoursite.com/2015/09/20/10-steps-to-learn-SQL/"/>
    <id>http://yoursite.com/2015/09/20/10-steps-to-learn-SQL/</id>
    <published>2015-09-19T16:47:18.000Z</published>
    <updated>2015-09-19T17:28:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1-SQL_一种声明式语言">1.SQL 一种声明式语言</h1><p>SQL是一种声“明式”语言。SQL语言是为计算机声明了一个你想从数据库中获得结果的范例（可以理解为SQL语句），而不是告诉计算机如何得到SQL查询的结果。</p>
<p>如果SQL语言这么简单，那么人么为什么“闻SQL色变”？主要原因是：潜意识中是按照编程命令式编程思维方式思考问题。就好比这样：程序执行顺训，从上到下，第一个函数执行完后在执行下一个。这种命令式编程的思维惯式。</p>
<h1 id="2-SQL_语法的执行顺序">2.SQL 语法的执行顺序</h1><p>SQL语句有一个非常困惑大家的特性：SQL语句的执行顺训跟SQL语句的语法顺训并不一致。SQL语句的执行顺序是：</p>
<pre><code>* <span class="keyword">FROM</span>
* <span class="keyword">WHERE</span>
* <span class="keyword">GROUP</span> <span class="keyword">BY</span>
* HAVING
* <span class="keyword">SELECT</span>
* <span class="keyword">DISTINCT</span>
* <span class="keyword">UNION</span>
* <span class="keyword">ORDER</span> <span class="keyword">BY</span>
</code></pre><p>这里我们需要注意三个地方</p>
<pre><code><span class="number">1</span>. <span class="keyword">FROM</span> 才是 SQL 语句执行的第一步，并非 <span class="keyword">SELECT</span>。数据库在执行语句第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。
<span class="number">2</span>. <span class="keyword">SELECT</span> 是在大部分语句执行后才执行的，严格的说是在 <span class="keyword">FROM</span> 和 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 之后执行的。理解这一点非常重要，这就是你不能在 <span class="keyword">WHERE</span> 中使用在 <span class="keyword">SELECT</span> 中设别名的字段作为判断条件的原因。
<span class="number">3</span>. 无论在语法还是执行顺序上，<span class="keyword">UNION</span> 总是排在 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 之前。很多人认为每个 <span class="keyword">UNION</span> 段都能使用 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序，但是根据 SQL 语言标准和各个数据库 SQL 的执行差异来看，这并不是真的。尽管某些数据库允许 SQL 语句对子查询或者派生表进行排序，但是这并不说明这个排序在 <span class="keyword">UNION</span> 操作过后仍保持排序的顺序。
 注意：并非所有的数据库对 SQL 语句使用相同的解析方式。如 MySQL、PostgreSQL 和 SQLite 中就不会按照第二点执行。
</code></pre><h3 id="我们学到了什么">我们学到了什么</h3><p>既然并不是所有的数据库都是按照上面方式执行，那我们学到了什么？我们的收获是永远要记得：SQL 语句的语法顺序和其执行顺序并不一致，这样我们就能避免一般性的错误。如果你能记住 SQL 语法顺序和执行顺序的差异，那你就能很容易的理解一些常见的 SQL 问题。</p>
<p>当然，如果一种语言被设计成语法顺序直接反应其语句的执行顺序，那么这种语言对程序员是十分友好的，如：微软的 LINO 语言。</p>
<h1 id="3-SQL_语言的核心是对表的引用（table_references）">3.SQL 语言的核心是对表的引用（table references）</h1><p>由于 SQL 语句语法顺序和执行顺序的不同，很多人认为 SELECT 中的字段信息是 SQL 语句的核心。但是真正的核心在于对表的引用。</p>
<p>根据 SQL 标准，FROM 语句被定义为：</p>
<pre><code><span class="tag">&lt;<span class="title">from</span> <span class="attribute">clause</span> &gt;</span> ::= FROM <span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> [ { <span class="tag">&lt;<span class="title">comma</span>&gt;</span> <span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> }... ]
</code></pre><p>FROM 语句的输出”是一张联合表，来自于所有引用的表在某一维度上的联合。我们来慢慢分析：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>上面这句 FROM 语句的输出是一张联合表，联合了表 a 和表 b 。如果 a 表有三个字段， b 表有 5 个字段，那么这个“输出表”就有 8 （ =5+3）个字段。</p>
<p>这个联合表里的数据是 a＊b，即 a 和 b 的笛卡尔积。换句话说，也就是 a 表中的每一条数据都要跟 b 表中的每一条数据配对。如果 a 表有3 条数据， b 表有 5 条数据，那么联合表就会有 15 （ =5＊3）条数据。</p>
<p>FROM 输出的结果被 WHERE 语句筛选后要经过 GROUP BY 语句处理，从而形成新的输出结果。我们后面还会再讨论这方面问题。</p>
<p>如果我们从集合论（关系代数）的角度来看，一张数据库的表就是一组数据元的关系，而每个 SQL 语句会改变一种或数种关系，从而产生出新的数据元的关系（即产生新的表）。</p>
<p>我们学到了什么？</p>
<p> 思考问题的时候从表的角度来思考问题，这样很容易理解数据如何在 SQL 语句的“流水线”上进行了什么样的变动。</p>
<h1 id="4-灵活引用表能使_SQL_语句变得更强大">4.灵活引用表能使 SQL 语句变得更强大</h1><p>灵活引用表能使 SQL 语句变得更强大。一个简单的例子就是 JOIN 的使用。严格的说 JOIN 语句并非是 SELECT 中的一部分，而是一种特殊的表引用语句。 SQL 语言标准中表的连接定义如下：</p>
<pre><code><span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> ::=
    <span class="tag">&lt;<span class="title">table</span> <span class="attribute">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">derived</span> <span class="attribute">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">joined</span> <span class="attribute">table</span>&gt;</span>
</code></pre><p>就拿之前的例子来说：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>a 可能输如下表的连接：</p>
<pre><code><span class="label">a1</span> JOIN <span class="literal">a2</span> ON <span class="literal">a1</span>.id = <span class="literal">a2</span>.id
</code></pre><p>将它放到之前的例子中就变成了：</p>
<pre><code><span class="label">FROM</span> <span class="literal">a1</span> JOIN <span class="literal">a2</span> ON <span class="literal">a1</span>.id = <span class="literal">a2</span>.id, <span class="keyword">b</span>
</code></pre><p>尽管将一个连接表用逗号跟另一张表联合在一起并不是常用作法，但是你的确可以这么做。结果就是，最终输出的表就有了 a1+a2+b 个字段了。</p>
<p>在 SQL 语句中派生表的应用甚至比表连接更加强大，下面我们就要讲到表连接。</p>
<h3 id="我们学到了什么？">我们学到了什么？</h3><p>思考问题时，要从表引用的角度出发，这样就很容易理解数据是怎样被 SQL 语句处理的，并且能够帮助你理解那些复杂的表引用是做什么的。</p>
<p>更重要的是，要理解 JOIN 是构建连接表的关键词，并不是 SELECT 语句的一部分。有一些数据库允许在 INSERT 、 UPDATE 、 DELETE 中使用 JOIN 。</p>
<h1 id="5-SQL_语句中推荐使用表连接">5.SQL 语句中推荐使用表连接</h1><p>我们先看看刚刚这句话：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>高级 SQL 程序员也许学会给你忠告：尽量不要使用逗号来代替 JOIN 进行表的连接，这样会提高你的 SQL 语句的可读性，并且可以避免一些错误。</p>
<p>利用逗号来简化 SQL 语句有时候会造成思维上的混乱，想一下下面的语句：</p>
<pre><code>FROM <span class="tag">a</span>, <span class="tag">b</span>, c, d, e, f, g, h
WHERE <span class="tag">a</span><span class="class">.a1</span> = <span class="tag">b</span><span class="class">.bx</span>
AND <span class="tag">a</span><span class="class">.a2</span> = c<span class="class">.c1</span>
AND d<span class="class">.d1</span> = <span class="tag">b</span><span class="class">.bc</span>
-- etc...
</code></pre><p>我们不难看出使用 JOIN 语句的好处在于：</p>
<pre><code><span class="bullet">* </span>安全。 JOIN 和要连接的表离得非常近，这样就能避免错误。
<span class="bullet">* </span>更多连接的方式，JOIN 语句能去区分出来外连接和内连接等。
</code></pre><h3 id="我们学到了什么？-1">我们学到了什么？</h3><p>记着要尽量使用 JOIN 进行表的连接，永远不要在 FROM 后面使用逗号连接表。</p>
<h1 id="6-SQL_语句中不同的连接操作">6.SQL 语句中不同的连接操作</h1><p>SQL 语句中，表连接的方式从根本上分为五种：</p>
<pre><code><span class="bullet">* </span>EQUI JOIN
<span class="bullet">* </span>SEMI JOIN
<span class="bullet">* </span>ANTI JOIN
<span class="bullet">* </span>CROSS JOIN
<span class="bullet">* </span>DIVISION
</code></pre><h3 id="EQUI_JOIN">EQUI JOIN</h3><p>这是一种最普通的 JOIN 操作，它包含两种连接方式：</p>
<pre><code>* INNER <span class="built_in">JOIN</span>（或者是 <span class="built_in">JOIN</span> ）
* OUTER <span class="built_in">JOIN</span>（包括： <span class="built_in">LEFT</span> 、 <span class="built_in">RIGHT</span>、 FULL OUTER <span class="built_in">JOIN</span>）
</code></pre><p>用例子最容易说明其中区别：</p>
<pre><code>-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books.
</span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.
</span>-<span class="ruby">- authors without books are <span class="constant">NOT</span> included
</span>author JOIN book ON author.id = book.author_id

-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books
</span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.
</span>-<span class="ruby">- ... <span class="constant">OR</span> there is an <span class="string">"empty"</span> record <span class="keyword">for</span> authors without books
</span>-<span class="ruby">- (<span class="string">"empty"</span> meaning that all book columns are <span class="constant">NULL</span>)
</span>author LEFT OUTER JOIN book ON author.id = book.author_id
</code></pre><h3 id="SEMI_JOIN">SEMI JOIN</h3><p>这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。“ SEMI ”在拉丁文中是“半”的意思。这种连接方式是只连接目标表的一部分。这是什么意思呢？再想一下关于作者和书名的连接。我们想象一下这样的情况：我们不需要作者 / 书名这样的组合，只是需要那些在书名表中的书的作者信息。那我们就能这么写：</p>
<pre><code>-- <span class="keyword">Using</span> <span class="keyword">IN</span>
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> author.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)

-- <span class="keyword">Using</span> EXISTS
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)
</code></pre><p>尽管没有严格的规定说明你何时应该使用 IN ，何时应该使用 EXISTS ，但是这些事情你还是应该知道的：</p>
<pre><code><span class="bullet">* </span>IN比 EXISTS 的可读性更好
<span class="bullet">* </span>EXISTS 比IN 的表达性更好（更适合复杂的语句）
<span class="bullet">* </span>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）
</code></pre><p>因为使用 INNER JOIN 也能得到书名表中书所对应的作者信息，所以很多初学者机会认为可以通过 DISTINCT 进行去重，然后将 SEMI JOIN 语句写成这样：</p>
<pre><code><span class="comment">-- Find only those authors who also have books</span>
<span class="operator">SELECT <span class="keyword">DISTINCT</span> first_name, last_name
<span class="keyword">FROM</span> author
<span class="keyword">JOIN</span> book <span class="keyword">ON</span> author.<span class="keyword">id</span> = book.author_id</span>
</code></pre><p>这是一种很糟糕的写法，原因如下：</p>
<pre><code><span class="bullet">* </span>SQL 语句性能低下：因为去重操作（ DISTINCT ）需要数据库重复从硬盘中读取数据到内存中。
<span class="bullet">* </span>这么写并非完全正确：尽管也许现在这么写不会出现问题，但是随着 SQL 语句变得越来越复杂，你想要去重得到正确的结果就变得十分困难。
</code></pre><p>更多的关于滥用 DISTINCT 的危害可以参考这篇博文</p>
<p>（<a href="http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/" target="_blank" rel="external">http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/</a>）。</p>
<h3 id="ANTI_JOIN">ANTI JOIN</h3><p>这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接。举个例子来说，我们列出书名表里没有书的作者：</p>
<pre><code>-- <span class="keyword">Using</span> <span class="keyword">IN</span>
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> author.id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)

-- <span class="keyword">Using</span> EXISTS
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)
</code></pre><p>关于性能、可读性、表达性等特性也完全可以参考 SEMI JOIN。</p>
<p>这篇博文介绍了在使用 NOT IN 时遇到 NULL 应该怎么办，因为有一点背离本篇主题，就不详细介绍，有兴趣的同学可以读一下</p>
<p>（<a href="http://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/" target="_blank" rel="external">http://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/</a>）。</p>
<h3 id="CROSS_JOIN">CROSS JOIN</h3><p>这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法。在实际的应用中，很少有地方能用到 CROSS JOIN，但是一旦用上了，你就可以用这样的 SQL语句表达：</p>
<pre><code>-- Combine <span class="keyword">every</span> author with <span class="keyword">every</span> book
author CROSS <span class="keyword">JOIN</span> book
</code></pre><h3 id="DIVISION">DIVISION</h3><p>DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来，介于这是一个新手指南，解释 DIVISION 已经超出了我们的目的。但是有兴趣的同学还是可以来看看这三篇文章</p>
<p>（<a href="http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/" target="_blank" rel="external">http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/</a>）</p>
<p>（<a href="http://en.wikipedia.org/wiki/Relational_algebra#Division" target="_blank" rel="external">http://en.wikipedia.org/wiki/Relational_algebra#Division</a>）</p>
<p>（<a href="https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/" target="_blank" rel="external">https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a>）。</p>
<p>推荐阅读 →_→ <a href="http://blog.jobbole.com/40443/" target="_blank" rel="external">《画图解释SQL联合语句》</a></p>
<h3 id="我们学到了什么？-2">我们学到了什么？</h3><p>学到了很多！让我们在脑海中再回想一下。 SQL 是对表的引用， JOIN 则是一种引用表的复杂方式。但是 SQL 语言的表达方式和实际我们所需要的逻辑关系之间是有区别的，并非所有的逻辑关系都能找到对应的 JOIN 操作，所以这就要我们在平时多积累和学习关系逻辑，这样你就能在以后编写 SQL 语句中选择适当的 JOIN 操作了。</p>
<h1 id="7-SQL_中如同变量的派生表">7.SQL 中如同变量的派生表</h1><p>在这之前，我们学习到过 SQL 是一种声明性的语言，并且 SQL 语句中不能包含变量。但是你能写出类似于变量的语句，这些就叫做派生表：</p>
<p>说白了，所谓的派生表就是在括号之中的子查询：</p>
<pre><code>-- A derived table
<span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author)
</code></pre><p>需要注意的是有些时候我们可以给派生表定义一个相关名（即我们所说的别名）。</p>
<pre><code>-- A derived table <span class="keyword">with</span> an <span class="keyword">alias</span>
<span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author) a
</code></pre><p>派生表可以有效的避免由于 SQL 逻辑而产生的问题。举例来说：如果你想重用一个用 SELECT 和 WHERE 语句查询出的结果，这样写就可以（以 Oracle 为例）：</p>
<pre><code>-- <span class="keyword">Get</span> authors<span class="comment">' first and last names, and their age in days</span>
<span class="keyword">SELECT</span> first_name, last_name, age
<span class="keyword">FROM</span> (
  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age
  <span class="keyword">FROM</span> author
)
-- <span class="keyword">If</span> the age <span class="keyword">is</span> greater than <span class="number">10000</span> days
<span class="keyword">WHERE</span> age &gt; <span class="number">10000</span>
</code></pre><p>需要我们注意的是：在有些数据库，以及 SQL ： 1990 标准中，派生表被归为下一级——通用表语句（ common table experssion）。这就允许你在一个 SELECT 语句中对派生表多次重用。上面的例子就（几乎）等价于下面的语句：</p>
<pre><code><span class="keyword">WITH</span> a <span class="keyword">AS</span> (
  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age
  <span class="keyword">FROM</span> author
)
<span class="keyword">SELECT</span> *
<span class="keyword">FROM</span> a
<span class="keyword">WHERE</span> age &gt; <span class="number">10000</span>
</code></pre><p>当然了，你也可以给“ a ”创建一个单独的视图，这样你就可以在更广泛的范围内重用这个派生表了。更多信息可以阅读下面的文章（<a href="http://en.wikipedia.org/wiki/View_%28SQL%29" target="_blank" rel="external">http://en.wikipedia.org/wiki/View_%28SQL%29</a>）。</p>
<h3 id="我们学到了什么？-3">我们学到了什么？</h3><p>我们反复强调，大体上来说 SQL 语句就是对表的引用，而并非对字段的引用。要好好利用这一点，不要害怕使用派生表或者其他更复杂的语句。</p>
<h1 id="8-SQL_语句中_GROUP_BY_是对表的引用进行的操作">8.SQL 语句中 GROUP BY 是对表的引用进行的操作</h1><p>让我们再回想一下之前的 FROM 语句：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>现在，我们将 GROUP BY 应用到上面的语句中：</p>
<pre><code>GROUP BY A<span class="class">.x</span>, A<span class="class">.y</span>, B.z
</code></pre><p>上面语句的结果就是产生出了一个包含三个字段的新的表的引用。我们来仔细理解一下这句话：当你应用 GROUP BY 的时候， SELECT 后没有使用聚合函数的列，都要出现在 GROUP BY 后面。</p>
<p>需要注意的是：其他字段能够使用聚合函数：</p>
<pre><code>SELECT A<span class="class">.x</span>, A<span class="class">.y</span>, <span class="function"><span class="title">SUM</span><span class="params">(A.z)</span></span>
FROM A
GROUP BY A<span class="class">.x</span>, A.y
</code></pre><p>还有一点值得留意的是： MySQL 并不坚持这个标准，这的确是令人很困惑的地方。但是不要被 MySQL 所迷惑。 GROUP BY 改变了对表引用的方式。你可以像这样既在 SELECT 中引用某一字段，也在 GROUP BY 中对其进行分组。</p>
<h3 id="我们学到了什么？-4">我们学到了什么？</h3><p>GROUP BY，再次强调一次，是在表的引用上进行了操作，将其转换为一种新的引用方式。</p>
<h1 id="9-SQL_语句中的_SELECT_实质上是对关系的映射">9.SQL 语句中的 SELECT 实质上是对关系的映射</h1><p>我个人比较喜欢“映射”这个词，尤其是把它用在关系代数上。一旦你建立起来了表的引用，经过修改、变形，你能够一步一步的将其映射到另一个模型中。 SELECT 语句就像一个“投影仪”，我们可以将其理解成一个将源表中的数据按照一定的逻辑转换成目标表数据的函数。</p>
<p>通过 SELECT语句，你能对每一个字段进行操作，通过复杂的表达式生成所需要的数据。</p>
<p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条：</p>
<pre><code><span class="number">1.</span> 你仅能够使用那些能通过表引用而得来的字段；
<span class="number">2.</span> 如果你有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句，你只能够使用 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句后面的字段或者聚合函数；
<span class="number">3.</span> 当你的语句中没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 的时候，可以使用开窗函数代替聚合函数；
<span class="number">4.</span> 当你的语句中没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 的时候，你不能同时使用聚合函数和其它函数；
<span class="number">5.</span> 有一些方法可以将普通函数封装在聚合函数中；
<span class="number">6.</span> ……
</code></pre><p>一些更复杂的规则多到足够写出另一篇文章了。比如：为何你不能在一个没有 GROUP BY 的 SELECT 语句中同时使用普通函数和聚合函数？（上面的第 4 条）</p>
<p>原因如下：</p>
<pre><code><span class="number">1</span>. 凭直觉，这种做法从逻辑上就讲不通。
<span class="number">2</span>. 如果直觉不能够说服你，那么语法肯定能。 SQL : <span class="number">1999</span> 标准引入了 GROUPING SETS，SQL： <span class="number">2003</span> 标准引入了 <span class="keyword">group</span> sets : <span class="keyword">GROUP</span> <span class="keyword">BY</span>() 。无论什么时候，只要你的语句中出现了聚合函数，而且并没有明确的 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句，这时一个不明确的、空的 GROUPING <span class="keyword">SET</span> 就会被应用到这段 SQL 中。因此，原始的逻辑顺序的规则就被打破了，映射（即 <span class="keyword">SELECT</span> ）关系首先会影响到逻辑关系，其次就是语法关系。（译者注：这段话原文就比较艰涩，可以简单理解如下：在既有聚合函数又有普通函数的 SQL 语句中，如果没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 进行分组，SQL 语句默认视整张表为一个分组，当聚合函数对某一字段进行聚合统计的时候，引用的表中的每一条 <span class="keyword">record</span> 就失去了意义，全部的数据都聚合为一个统计值，你此时对每一条 <span class="keyword">record</span> 使用其它函数是没有意义的）。
</code></pre><p>糊涂了？是的，我也是。我们再回过头来看点浅显的东西吧。</p>
<h3 id="我们学到了什么？-5">我们学到了什么？</h3><p>SELECT 语句可能是 SQL 语句中最难的部分了，尽管他看上去很简单。其他语句的作用其实就是对表的不同形式的引用。而 SELECT 语句则把这些引用整合在了一起，通过逻辑规则将源表映射到目标表，而且这个过程是可逆的，我们可以清楚的知道目标表的数据是怎么来的。</p>
<p>想要学习好 SQL 语言，就要在使用 SELECT 语句之前弄懂其他的语句，虽然 SELECT 是语法结构中的第一个关键词，但它应该是我们最后一个掌握的。</p>
<h1 id="10-SQL_语句中的几个简单的关键词：DISTINCT，UNION，ORDER_BY_和_OFFSET">10.SQL 语句中的几个简单的关键词：DISTINCT，UNION，ORDER BY 和 OFFSET</h1><p>在学习完复杂的 SELECT 豫剧之后，我们再来看点简单的东西：</p>
<pre><code>* 集合运算（ <span class="keyword">DISTINCT</span> 和 <span class="keyword">UNION</span> ）
* 排序运算（ <span class="keyword">ORDER</span> <span class="keyword">BY</span>，OFFSET…FETCH）
</code></pre><h3 id="集合运算（_set_operation）：">集合运算（ set operation）：</h3><p>集合运算主要操作在于集合上，事实上指的就是对表的一种操作。从概念上来说，他们很好理解：</p>
<pre><code><span class="bullet">* </span>DISTINCT 在映射之后对数据进行去重
<span class="bullet">* </span>UNION 将两个子查询拼接起来并去重
<span class="bullet">* </span>UNION ALL 将两个子查询拼接起来但不去重
<span class="bullet">* </span>EXCEPT 将第二个字查询中的结果从第一个子查询中去掉
<span class="bullet">* </span>INTERSECT 保留两个子查询中都有的结果并去重
</code></pre><h3 id="排序运算（_ordering_operation）：">排序运算（ ordering operation）：</h3><p>排序运算跟逻辑关系无关。这是一个 SQL 特有的功能。排序运算不仅在 SQL 语句的最后，而且在 SQL 语句运行的过程中也是最后执行的。使用 ORDER BY 和 OFFSET…FETCH 是保证数据能够按照顺序排列的最有效的方式。其他所有的排序方式都有一定随机性，尽管它们得到的排序结果是可重现的。</p>
<p>OFFSET…SET是一个没有统一确定语法的语句，不同的数据库有不同的表达方式，如 MySQL 和 PostgreSQL 的 LIMIT…OFFSET、SQL Server 和 Sybase 的 TOP…START AT 等。具体关于 OFFSET..FETCH 的不同语法可以参考这篇文章<br>（<a href="http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/" target="_blank" rel="external">http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/</a>）。</p>
<p>让我们在工作中尽情的使用 SQL！</p>
<p>正如其他语言一样，想要学好 SQL 语言就要大量的练习。上面的 10 个简单的步骤能够帮助你对你每天所写的 SQL 语句有更好的理解。另一方面来讲，从平时常见的错误中也能积累到很多经验。</p>
<p>基本参考<a href="http://blog.jobbole.com/55086/" target="_blank" rel="external">十步完全理解SQL</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-SQL_一种声明式语言">1.SQL 一种声明式语言</h1><p>SQL是一种声“明式”语言。SQL语言是为计算机声明了一个你想从数据库中获得结果的范例（可以理解为SQL语句），而不是告诉计算机如何得到SQL查询的结果。</p>
<p>如果SQL语言这么简单]]>
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <link href="http://yoursite.com/2015/09/12/hello-world/"/>
    <id>http://yoursite.com/2015/09/12/hello-world/</id>
    <published>2015-09-12T15:55:08.000Z</published>
    <updated>2015-09-12T15:55:08.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to My Notes! This is my very first post. 开始写博客了，一直以来想把自己的学习的东西记录下来，可能比较懒吧，最近才开始有了真实的行动来完成。</p>
<h2 id="构建博客的框架">构建博客的框架</h2><pre><code>结构采用比较流行的 hexo，之所以选择他是因为他方便、快。
博客主题采用的是当前星最高的也是我比较喜欢的主题 <span class="keyword">next</span>。
</code></pre><h2 id="博客的主要内容">博客的主要内容</h2><pre><code>主要记录自己在工作学习中用的知识点，以备平时需要时查询，也希望大家来交流下经验。
</code></pre><h2 id="后记">后记</h2><pre><code>比自己聪明的人还在努力的学习，我有什么资格来放弃学习！
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to My Notes! This is my very first post. 开始写博客了，一直以来想把自己的学习的东西记录下来，可能比较懒吧，最近才开始有了真实的行动来完成。</p>
<h2 id="构建博客的框架">构建博客的框架</h2><pre>]]>
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
