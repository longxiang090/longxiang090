<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[WooLong's Notes]]></title>
  <subtitle><![CDATA[生命不息，奋斗不止]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-09-28T18:33:17.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[WooLong]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[MySQL 索引简介]]></title>
    <link href="http://yoursite.com/2015/09/29/MySQL-%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2015/09/29/MySQL-索引简介/</id>
    <published>2015-09-28T18:02:31.000Z</published>
    <updated>2015-09-28T18:33:17.000Z</updated>
    <content type="html"><![CDATA[<p>索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。索引是在存储引擎中实现的，而不是在服务器层中实现的。几种常见的索引类型：</p>
<h3 id="B-Tree类型的索引">B-Tree类型的索引</h3><ul>
<li>普通索引(Normal Indexes)—普通索引是最基本的索引而且没有任何限制(比如唯一性等限制)。普通索引可以包含重复的值。</li>
<li>唯一索引(Unique Indexes)—唯一索引和普通索引基本上是相同的。有一点不同的是：使用唯一索引的索引的列的所有值必须是唯一的，在该列中不能使用重复的值，但可以使用null。如果是组合索引，则列值的组合必须唯一。</li>
<li>主键索引(Primary keys)—它是一种特殊的唯一索引，不允许有空值。主键索引相当于“唯一索引+not null”。所有使用主键索引的列必须唯一并且不能为空。通常我们使用”auto_increment”来设置主键。 </li>
<li>全文索引(Full-text Indexes)—全文索引用在MySQL的全文搜索中。通常这种索引被用在搜索引擎类的应用中，用来从某个字段中检索特别的关键字。目前只有MyISAM引擎支持。</li>
</ul>
<p>B-Tree类型的索引可以用于表达式中列的比较，如&gt;、&gt;=、&lt;、&lt;=或BETWEEN运算符。这种类型的索引也可以用在LIKE、IN、IS NULL等的比较中。当然，在某些场景下，MySQL并不会使用索引，如NOT IN、IS NOT NULL,、LIKE ‘%sql%’ 等。</p>
<h3 id="空间索引(Spacial_Indexes)(R-tree)">空间索引(Spacial Indexes)(R-tree)</h3><p>只有MyISAM存储引擎才支持空间索引。它就像B-Tree索引一样，但是它并不仅仅遵循从做到右的顺序。空间索引仅仅被用在某些特殊的场景中，如MySQL GIS functions。</p>
<h3 id="哈希索引(Hash_Indexes)">哈希索引(Hash Indexes)</h3><p>hash就是一种（key=&gt;value）形式的键值对，哈希索引完全不同于B-Tree索引。哈希索引只能被用在相等比较中，如”=”和”!=”操作，而且速度非常快。目前只有Memory 存储引擎支持哈希索引。</p>
<h3 id="引用">引用</h3><p>［<a href="http://www.php101.cn/2014/08/14/MySQl%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/］" target="_blank" rel="external">http://www.php101.cn/2014/08/14/MySQl%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/］</a><br>［<a href="http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html］" target="_blank" rel="external">http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html］</a><br>［<a href="http://blog.csdn.net/dyllove98/article/details/9631303］" target="_blank" rel="external">http://blog.csdn.net/dyllove98/article/details/9631303］</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。索引是在存储引擎中实现的，而不是在服务器层中实现的。几种常见的索引类型：</p>
<h3 id="B-Tree类型的索引">B-Tree类型的索引</h3><ul>
<li>普通索引(Normal I]]>
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript 对象与 JOSON]]></title>
    <link href="http://yoursite.com/2015/09/28/javascript-%E5%AF%B9%E8%B1%A1%E4%B8%8E-JOSON/"/>
    <id>http://yoursite.com/2015/09/28/javascript-对象与-JOSON/</id>
    <published>2015-09-27T17:41:41.000Z</published>
    <updated>2015-09-28T09:28:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>JavaScript 对象与传统的面向对象中的对象几乎没有相似之处，传统的面向对象语言中，创建一个对象必须先有对象的模板：类，类中定义了对象的属性和操作这些属性的方法。通过实例化来构筑一个对象，然后使用对象间的协作来完成一项功能，通过功能的集合来完成整个工程。而Javascript中是没有类的概念的，借助JavaScript的动态性，我们完全可以创建一个空的对象(而不是类)，通过像对象动态的添加属性来完善对象的功能。 </p>
<p>JSON 即 JavaScript Object Notation 是一种轻量级数据交换格式，采用完全独立于语言的文本格式，非常适合于服务器与 JavaScript 的交互，当两个应用程序、或者两台服务器、或者两种语言之间进行“交流”时，他们都趋向于采用字符串。</p>
<p>JSON 是一种数据交换格式，像 XML 和 YAML 一样是一种在各种不同语言间传递结构化信息的方式。从另一方面来说，JavaScript 对象是 JavaScript 语言中的一种数据类型，就像 PHP 中的数组、C++ 中类和结构体。</p>
<h3 id="定义_JSON_与_JavaScript">定义 JSON 与 JavaScript</h3><p>在 JavaScript 程序中定义对象的时候，对象的属性名可以加双引号也可以不加双引号。如果属性名包含特殊字符(如!、if等)的时候，就必须加双引号。<br>在定义 JSON 的时候，属性名必须加双引号。</p>
<p>代码示例：</p>
<p>1.定义 JavaScript 对象</p>
<pre><code><span class="number">1.</span> var obj = {name: <span class="string">"woolong"</span>, <span class="string">"gender"</span>: <span class="string">"man"</span>}; <span class="preprocessor"># 两个属性可以加双引号也可以不加</span>
<span class="number">2.</span> var obj = {<span class="string">"!"</span>: <span class="string">"hello word"</span>}; <span class="preprocessor"># 属性名包含特殊字符时必须加双引号 </span>
</code></pre><p>2.定义 JSON 字符串</p>
<pre><code><span class="number">1.</span> var jsonStr = {<span class="string">"name"</span>: <span class="string">"woolong"</span>}; <span class="preprocessor"># 定义 JSON 时必须加双引号。</span>
</code></pre><h3 id="JavaScript_对象转换为_JSON">JavaScript 对象转换为 JSON</h3><p>我们可以使用 JavaScript 的内置函数将 JavaScript 对象转换为 JSON，这个函数就是 JSON.stringify()。</p>
<p>代码示例：</p>
<pre><code>1. var obj = {name: <span class="string">"woolong"</span>, <span class="keyword">gender</span>: <span class="string">"man"</span>};
2. var jsonObj = JSON.stringify(obj);
3. console.log(jsonObj); // 输出结果为：{<span class="string">"name"</span>: <span class="string">"woolong"</span>, <span class="string">"gender"</span>: <span class="string">"man"</span>}
</code></pre><p>在将 JavaScript 对象转换为 JSON 的时候，有一点是需要我们注意的：<br>如果对象中包含有值为函数和日期的属性，JSON 会忽略值为函数的属性，并将值为日期的属性转换为字符串。<br>代码示例：</p>
<pre><code><span class="number">1.</span> var obj = {
<span class="number">2.</span>             name: <span class="string">"woolong"</span>,
<span class="number">3.</span>             birthday: <span class="keyword">new</span> Date(),
<span class="number">4.</span>             action: function () {
<span class="number">5.</span>                     document.write(<span class="string">"wolf"</span>);
<span class="number">6.</span>             }
<span class="number">7.</span> };
<span class="number">8.</span> var jsonObj = JSON.stringify(obj);
<span class="number">9.</span> console.<span class="built_in">log</span>(jsonObj); <span class="comment">//输出结果为：{"name":"woolong","birthday":"2015-09-28T08:47:44.358Z"}</span>
</code></pre><h3 id="JavaScript_中解析_JSON">JavaScript 中解析 JSON</h3><p>在老版本的 JS 中，大家通常都使用 eval() 函数来解析 JSON，但是 ECMAScript5 给我们提供了一个解析 JSON 的新函数 JSON.parse()。<br>这个函数的使用方法比较简单，大家可以自行尝试。当对某个 JSON 字符串应用该函数以后，该 JSON 就被转换为 JavaScript 的对象，也就是说当用 typeof 运算符查看该函数的类型时，返回的值是 Object。<br>同样有一点需要注意的是，该函数是 ECMAScript5 以后才支持的，如果是旧版本的浏览器那么可能不支持该函数。解决的方法是加载一个实现该函数的 JS 文件，即 json2.js。如果使用的是 JQuery 框架，jQuery.parseJSON()，该函数调用了 JSON.parse() 方法。<br>关于使用 eval() 方法解析 JSON ，这个等深入学习后会记录下来。</p>
<h3 id="一个很重要的概念">一个很重要的概念</h3><p>作为一个前端菜鸟，经常听到别人说“JSON对象”，但是其实并没有“JSON对象”这个概念，JSON真正的表现形式是字符串。</p>
<h3 id="引用">引用</h3><p>[<a href="http://www.php101.cn/2014/08/12/javascript%E5%AF%B9%E8%B1%A1%E4%B8%8EJSON/" target="_blank" rel="external">http://www.php101.cn/2014/08/12/javascript%E5%AF%B9%E8%B1%A1%E4%B8%8EJSON/</a>]</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="简介">简介</h3><p>JavaScript 对象与传统的面向对象中的对象几乎没有相似之处，传统的面向对象语言中，创建一个对象必须先有对象的模板：类，类中定义了对象的属性和操作这些属性的方法。通过实例化来构筑一个对象，然后使用对象间的协作来完成一项功能，通过功]]>
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 创建分支]]></title>
    <link href="http://yoursite.com/2015/09/25/Git-%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF/"/>
    <id>http://yoursite.com/2015/09/25/Git-创建分支/</id>
    <published>2015-09-25T08:12:20.000Z</published>
    <updated>2015-09-25T13:45:14.000Z</updated>
    <content type="html"><![CDATA[<p>使用 Git 本地创建分支</p>
<h5 id="1-_查看分支">1. 查看分支</h5><pre><code>git branch
/<span class="keyword">*</span><span class="keyword">*</span> 这里会列出所有本地的分支，查看原称分支 git branch -a <span class="keyword">*</span><span class="keyword">*</span>/
</code></pre><h5 id="2-_创建本地分支">2. 创建本地分支</h5><pre><code>git checkout -b test1
/<span class="keyword">*</span><span class="keyword">*</span> git checktout 也是切换分支<span class="keyword">*</span><span class="keyword">*</span>/
</code></pre><h5 id="3-_提交到远程">3. 提交到远程</h5><pre><code>上一步虽然创建了分支，但是远程还没有该分支，需要提交一次
</code></pre><p>备注下来，以便查阅，后续会有改动。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用 Git 本地创建分支</p>
<h5 id="1-_查看分支">1. 查看分支</h5><pre><code>git branch
/<span class="keyword">*</span><span class="keyword">*</span> 这里会列出所]]>
    </summary>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP 缓存技术]]></title>
    <link href="http://yoursite.com/2015/09/22/PHP-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2015/09/22/PHP-缓存技术/</id>
    <published>2015-09-22T09:23:35.000Z</published>
    <updated>2015-09-22T16:12:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_数据缓存">1. 数据缓存</h3><p>主要是指数据库查询结果的缓存，每次访问页面的时候先检测响应的缓存数据是否存在，如果不存在，就连接数据库查询数据，并把查询结果保存到文件中，以后同样的查询结果就直接从缓存中获取。用空间（硬盘）换速度是关键点。</p>
<h3 id="2-_内存缓存">2. 内存缓存</h3><p>Memcached是高性能的分布式内存缓存服务器。一般的使用目的是通过缓存数据库查询结果，减少数据库的访问次数，以提高动态 WEB 的访问速度、减少数据库负载。</p>
<p>它是将需要缓存的信息，缓存到系统内存中，需要获取信息中，直接到内存中取，比较常用的方式是 key-&gt;value 方式。</p>
<h3 id="3-_页面缓存">3. 页面缓存</h3><p>访问 WEB 页面时，先检测相应的缓存页面文件是否存在，如果不存在，则连接数据库，查询数据，显示页面并同时生成缓存页面文件，下次访问的时候缓存的页面文件就发挥作用了。页面缓存有一下几种方式。</p>
<h6 id="时间触发缓存">时间触发缓存</h6><p>检查文件是否存在并且缓存时间是否过期,如果文件修改的时间没有过期时间，那么就用缓存，否则更新缓存。</p>
<h6 id="内容出发缓存">内容出发缓存</h6><p>当页面数据有更新时，更改数据库的同时也强制更新缓存。</p>
<h6 id="页面部分缓存">页面部分缓存</h6><p>将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示；可以使用类似于 ob_get_contents 的方式实现，也可以利用类似 ESI 之类的页面片段缓存策略，使其用来做动态页面中相对静态的片段部分的缓存。该种方式可以用于如商城中的商品页；</p>
<h6 id="全页面静态化缓存">全页面静态化缓存</h6><p>直接生成HTML或XML等文本文件，有更新的时候重生成一次，而不会去走php服务器解析的流程，适合于不太变化的页面。</p>
<h3 id="4-_PHP_的OPCode（缓冲器、加速器）缓存">4. PHP 的OPCode（缓冲器、加速器）缓存</h3><p>有eAccelerator， APC， PHPA，XCache，这个没有太深的研究，暂不多说。</p>
<h3 id="5-_Apache_缓存模块">5.  Apache 缓存模块</h3><p>Apache 安装完以后，是不允许被 cache 的。如果外接了cache 或 squid 服务器要求进行 web 加速的话，就需要在 htttpd.conf 里进行设置，当然前提是在安装 Apache 的时候要激活 mod_cache 的模块。<br>安装 Apache 时：./configure –enable-cache –enable-disk-cache –enable-mem-cache</p>
<h3 id="6-_基于反向代理的_WEB_缓存">6.  基于反向代理的 WEB 缓存</h3><p>如 Nginx ，SQUID ，mod_proxy ( apache2 以上又分为 mod_proxy 和 mod_cache )</p>
<h3 id="7-_DNS_轮询">7. DNS 轮询</h3><p>大多域名注册商都支持多条A记录的解析，其实这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，逐一分配到不同的IP上，这样就完成了简单的负载均衡。更深层次的暂未研究。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_数据缓存">1. 数据缓存</h3><p>主要是指数据库查询结果的缓存，每次访问页面的时候先检测响应的缓存数据是否存在，如果不存在，就连接数据库查询数据，并把查询结果保存到文件中，以后同样的查询结果就直接从缓存中获取。用空间（硬盘）换速度是关键点。</p>
]]>
    </summary>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP的运行模式（理论）]]></title>
    <link href="http://yoursite.com/2015/09/21/PHP%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/09/21/PHP的运行模式/</id>
    <published>2015-09-21T08:52:19.000Z</published>
    <updated>2015-09-22T09:30:51.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍几种运行模式：CGI 通用网关接口(Common Gateway Interface)、FAST-CGI 常驻性 CGI(long-live CGI)、CLI 命令行运行(Command Line Interface)。</p>
<h3 id="1-_CGI_通用网关接口_(Common_Gateway_Interface)">1. CGI 通用网关接口 (Common Gateway Interface)</h3><p>CGI是一段程序，就像桥梁一样连接着 HTML 和 WEB 服务器，它把 HTML 接收到的指令传递给服务器的执行程序，在把服务器的运行结果返回给 HTML 。CGI 的跨平台性能非常的好，几乎可以在所有的操作系统上实现。但是 CGI 已经是比较老的模式了，最近几年很少用，被FAST－CGI替代。</p>
<p>当有一个请求时，首先要创建一个CGI子进程，然后处理请求，处理完后在结束该子进程，这就是 fork－and－execute 模式。如果用户的请iu数量非常多时，会产生大量的CGI子进程，有多少个请求就会产生多少个子进程，这样会大量挤占系统的资源如 CPU、内存等，这是造成 CGI 性能低下的主要原因。</p>
<h3 id="2-_FAST-CGI_常驻性_CGI(long-live_CGI)">2. FAST-CGI 常驻性 CGI(long-live CGI)</h3><p>fast-cgi 是cgi的升级版本，FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一 次 (这是 CGI 最为人诟病的 fork-and-execute 模式)。PHP使用PHP-FPM(FastCGI Process Manager)，全称PHP FastCGI进程管理器进行管理。</p>
<p>FastCGI的工作原理：</p>
<ol>
<li><p>Web Server启动时载入FastCGI进程管理器(IIS ISAPI或Apache Module)</p>
</li>
<li><p>FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自Web Server的连接。</p>
</li>
<li><p>当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi 。</p>
</li>
<li><p>FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server 。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器 (运行在Web Server中)的下一个连接。 在 CGI 模式中，php-cgi 在此便退出了。</p>
</li>
</ol>
<p>在上述情况中，你可以想象 CGI 通常有多慢。每一个 Web 请求 PHP 都必须重新解析 php.ini、重新载入全部扩展并重初始化全部数据结构。使用 FastCGI ，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接 (Persistent database connection) 可以工作。</p>
<p>Fastcgi的优点：</p>
<ol>
<li><p>从稳定性上看, FastCGI 是以独立的进程池来运行 CGI ,单独一个进程死掉,系统可以很轻易的丢弃该进程,然后重新分配新的进程来运行逻辑。</p>
</li>
<li><p>从安全性上看, FastCGI 支持分布式运算。FastCGI 和宿主的 server 完全独立, FastCGI 挂掉的话不会影响宿主 server。</p>
</li>
<li><p>从性能上看, FastCGI 把动态逻辑的处理从 server 中分离出来, 大负荷的 IO 处理还是留给宿主 server, 宿主 server 只进行 IO 处理。对于一个普通的动态网页来说, 逻辑处理可能只有一小部分,FastCGI 进程暂用的系统资源会非常少，配合静态缓存页面，性能会得到很大的提升。</p>
</li>
</ol>
<p>Fastcgi的优点：</p>
<ul>
<li>从实际使用来看，用 FastCGI 模式更适合生产环境的服务器。但对于开发用机器来说就不太合适。因为当使用 Zend Studio 调试程序时，由于 FastCGI 会认为 PHP 进程超时，从而在页面返回 500错误。</li>
<li>目前的 FastCGI 和 Server 沟通还不够智能，一个 FastCGI 进程如果执行时间过长会被当成是死进程杀掉重起，这样在处理长时间任务的时候很麻烦，这样做也使得 FastCGI 无法允许联机调试。因为是多进程，所以比 CGI 多线程消耗更多的服务器内存，PHP-CGI 解释器每进程消耗 7 至 25 兆内存，将这个数字乘以 50 或 100 就是很大的内存数。</li>
</ul>
<h3 id="3-_CLI_命令行运行(Command_Line_Interface)">3. CLI 命令行运行(Command Line Interface)</h3><p>它是 PHP 的命令行运行模式，大家经常使用它，但是可能并没有注意到（命令行中使用 php -v 等，有兴趣的可以输入 php -h 深入研究）</p>
<p>优点：</p>
<ol>
<li><p>使用多进程，子进程结束以后，内核会负责回收资源。</p>
</li>
<li><p>使用多进程，子进程异常退出不会导致整个进程 Thread 退出，父进程还有机会重建流程；</p>
</li>
<li><p>一个常驻主进程，只负责任务分发，逻辑更清楚。</p>
</li>
</ol>
<h3 id="总结">总结</h3><p>每种运行模式都有自己的优缺点，没有绝对的好与坏，主要是看运行的环境。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍几种运行模式：CGI 通用网关接口(Common Gateway Interface)、FAST-CGI 常驻性 CGI(long-live CGI)、CLI 命令行运行(Command Line Interface)。</p>
<h3 id="1-_CGI_通]]>
    </summary>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="运行模式" scheme="http://yoursite.com/tags/%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[完全理解 SQL 之 SELECT 句式]]></title>
    <link href="http://yoursite.com/2015/09/20/10-steps-to-learn-SQL/"/>
    <id>http://yoursite.com/2015/09/20/10-steps-to-learn-SQL/</id>
    <published>2015-09-19T16:47:18.000Z</published>
    <updated>2015-09-19T17:28:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1-SQL_一种声明式语言">1.SQL 一种声明式语言</h1><p>SQL是一种声“明式”语言。SQL语言是为计算机声明了一个你想从数据库中获得结果的范例（可以理解为SQL语句），而不是告诉计算机如何得到SQL查询的结果。</p>
<p>如果SQL语言这么简单，那么人么为什么“闻SQL色变”？主要原因是：潜意识中是按照编程命令式编程思维方式思考问题。就好比这样：程序执行顺训，从上到下，第一个函数执行完后在执行下一个。这种命令式编程的思维惯式。</p>
<h1 id="2-SQL_语法的执行顺序">2.SQL 语法的执行顺序</h1><p>SQL语句有一个非常困惑大家的特性：SQL语句的执行顺训跟SQL语句的语法顺训并不一致。SQL语句的执行顺序是：</p>
<pre><code>* <span class="keyword">FROM</span>
* <span class="keyword">WHERE</span>
* <span class="keyword">GROUP</span> <span class="keyword">BY</span>
* HAVING
* <span class="keyword">SELECT</span>
* <span class="keyword">DISTINCT</span>
* <span class="keyword">UNION</span>
* <span class="keyword">ORDER</span> <span class="keyword">BY</span>
</code></pre><p>这里我们需要注意三个地方</p>
<pre><code><span class="number">1</span>. <span class="keyword">FROM</span> 才是 SQL 语句执行的第一步，并非 <span class="keyword">SELECT</span>。数据库在执行语句第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。
<span class="number">2</span>. <span class="keyword">SELECT</span> 是在大部分语句执行后才执行的，严格的说是在 <span class="keyword">FROM</span> 和 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 之后执行的。理解这一点非常重要，这就是你不能在 <span class="keyword">WHERE</span> 中使用在 <span class="keyword">SELECT</span> 中设别名的字段作为判断条件的原因。
<span class="number">3</span>. 无论在语法还是执行顺序上，<span class="keyword">UNION</span> 总是排在 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 之前。很多人认为每个 <span class="keyword">UNION</span> 段都能使用 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序，但是根据 SQL 语言标准和各个数据库 SQL 的执行差异来看，这并不是真的。尽管某些数据库允许 SQL 语句对子查询或者派生表进行排序，但是这并不说明这个排序在 <span class="keyword">UNION</span> 操作过后仍保持排序的顺序。
 注意：并非所有的数据库对 SQL 语句使用相同的解析方式。如 MySQL、PostgreSQL 和 SQLite 中就不会按照第二点执行。
</code></pre><h3 id="我们学到了什么">我们学到了什么</h3><p>既然并不是所有的数据库都是按照上面方式执行，那我们学到了什么？我们的收获是永远要记得：SQL 语句的语法顺序和其执行顺序并不一致，这样我们就能避免一般性的错误。如果你能记住 SQL 语法顺序和执行顺序的差异，那你就能很容易的理解一些常见的 SQL 问题。</p>
<p>当然，如果一种语言被设计成语法顺序直接反应其语句的执行顺序，那么这种语言对程序员是十分友好的，如：微软的 LINO 语言。</p>
<h1 id="3-SQL_语言的核心是对表的引用（table_references）">3.SQL 语言的核心是对表的引用（table references）</h1><p>由于 SQL 语句语法顺序和执行顺序的不同，很多人认为 SELECT 中的字段信息是 SQL 语句的核心。但是真正的核心在于对表的引用。</p>
<p>根据 SQL 标准，FROM 语句被定义为：</p>
<pre><code><span class="tag">&lt;<span class="title">from</span> <span class="attribute">clause</span> &gt;</span> ::= FROM <span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> [ { <span class="tag">&lt;<span class="title">comma</span>&gt;</span> <span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> }... ]
</code></pre><p>FROM 语句的输出”是一张联合表，来自于所有引用的表在某一维度上的联合。我们来慢慢分析：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>上面这句 FROM 语句的输出是一张联合表，联合了表 a 和表 b 。如果 a 表有三个字段， b 表有 5 个字段，那么这个“输出表”就有 8 （ =5+3）个字段。</p>
<p>这个联合表里的数据是 a＊b，即 a 和 b 的笛卡尔积。换句话说，也就是 a 表中的每一条数据都要跟 b 表中的每一条数据配对。如果 a 表有3 条数据， b 表有 5 条数据，那么联合表就会有 15 （ =5＊3）条数据。</p>
<p>FROM 输出的结果被 WHERE 语句筛选后要经过 GROUP BY 语句处理，从而形成新的输出结果。我们后面还会再讨论这方面问题。</p>
<p>如果我们从集合论（关系代数）的角度来看，一张数据库的表就是一组数据元的关系，而每个 SQL 语句会改变一种或数种关系，从而产生出新的数据元的关系（即产生新的表）。</p>
<p>我们学到了什么？</p>
<p> 思考问题的时候从表的角度来思考问题，这样很容易理解数据如何在 SQL 语句的“流水线”上进行了什么样的变动。</p>
<h1 id="4-灵活引用表能使_SQL_语句变得更强大">4.灵活引用表能使 SQL 语句变得更强大</h1><p>灵活引用表能使 SQL 语句变得更强大。一个简单的例子就是 JOIN 的使用。严格的说 JOIN 语句并非是 SELECT 中的一部分，而是一种特殊的表引用语句。 SQL 语言标准中表的连接定义如下：</p>
<pre><code><span class="tag">&lt;<span class="title">table</span> <span class="attribute">reference</span>&gt;</span> ::=
    <span class="tag">&lt;<span class="title">table</span> <span class="attribute">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">derived</span> <span class="attribute">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">joined</span> <span class="attribute">table</span>&gt;</span>
</code></pre><p>就拿之前的例子来说：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>a 可能输如下表的连接：</p>
<pre><code><span class="label">a1</span> JOIN <span class="literal">a2</span> ON <span class="literal">a1</span>.id = <span class="literal">a2</span>.id
</code></pre><p>将它放到之前的例子中就变成了：</p>
<pre><code><span class="label">FROM</span> <span class="literal">a1</span> JOIN <span class="literal">a2</span> ON <span class="literal">a1</span>.id = <span class="literal">a2</span>.id, <span class="keyword">b</span>
</code></pre><p>尽管将一个连接表用逗号跟另一张表联合在一起并不是常用作法，但是你的确可以这么做。结果就是，最终输出的表就有了 a1+a2+b 个字段了。</p>
<p>在 SQL 语句中派生表的应用甚至比表连接更加强大，下面我们就要讲到表连接。</p>
<h3 id="我们学到了什么？">我们学到了什么？</h3><p>思考问题时，要从表引用的角度出发，这样就很容易理解数据是怎样被 SQL 语句处理的，并且能够帮助你理解那些复杂的表引用是做什么的。</p>
<p>更重要的是，要理解 JOIN 是构建连接表的关键词，并不是 SELECT 语句的一部分。有一些数据库允许在 INSERT 、 UPDATE 、 DELETE 中使用 JOIN 。</p>
<h1 id="5-SQL_语句中推荐使用表连接">5.SQL 语句中推荐使用表连接</h1><p>我们先看看刚刚这句话：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>高级 SQL 程序员也许学会给你忠告：尽量不要使用逗号来代替 JOIN 进行表的连接，这样会提高你的 SQL 语句的可读性，并且可以避免一些错误。</p>
<p>利用逗号来简化 SQL 语句有时候会造成思维上的混乱，想一下下面的语句：</p>
<pre><code>FROM <span class="tag">a</span>, <span class="tag">b</span>, c, d, e, f, g, h
WHERE <span class="tag">a</span><span class="class">.a1</span> = <span class="tag">b</span><span class="class">.bx</span>
AND <span class="tag">a</span><span class="class">.a2</span> = c<span class="class">.c1</span>
AND d<span class="class">.d1</span> = <span class="tag">b</span><span class="class">.bc</span>
-- etc...
</code></pre><p>我们不难看出使用 JOIN 语句的好处在于：</p>
<pre><code><span class="bullet">* </span>安全。 JOIN 和要连接的表离得非常近，这样就能避免错误。
<span class="bullet">* </span>更多连接的方式，JOIN 语句能去区分出来外连接和内连接等。
</code></pre><h3 id="我们学到了什么？-1">我们学到了什么？</h3><p>记着要尽量使用 JOIN 进行表的连接，永远不要在 FROM 后面使用逗号连接表。</p>
<h1 id="6-SQL_语句中不同的连接操作">6.SQL 语句中不同的连接操作</h1><p>SQL 语句中，表连接的方式从根本上分为五种：</p>
<pre><code><span class="bullet">* </span>EQUI JOIN
<span class="bullet">* </span>SEMI JOIN
<span class="bullet">* </span>ANTI JOIN
<span class="bullet">* </span>CROSS JOIN
<span class="bullet">* </span>DIVISION
</code></pre><h3 id="EQUI_JOIN">EQUI JOIN</h3><p>这是一种最普通的 JOIN 操作，它包含两种连接方式：</p>
<pre><code>* INNER <span class="built_in">JOIN</span>（或者是 <span class="built_in">JOIN</span> ）
* OUTER <span class="built_in">JOIN</span>（包括： <span class="built_in">LEFT</span> 、 <span class="built_in">RIGHT</span>、 FULL OUTER <span class="built_in">JOIN</span>）
</code></pre><p>用例子最容易说明其中区别：</p>
<pre><code>-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books.
</span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.
</span>-<span class="ruby">- authors without books are <span class="constant">NOT</span> included
</span>author JOIN book ON author.id = book.author_id

-<span class="ruby">- <span class="constant">This</span> table reference contains authors <span class="keyword">and</span> their books
</span>-<span class="ruby">- <span class="constant">There</span> is one record <span class="keyword">for</span> each book <span class="keyword">and</span> its author.
</span>-<span class="ruby">- ... <span class="constant">OR</span> there is an <span class="string">"empty"</span> record <span class="keyword">for</span> authors without books
</span>-<span class="ruby">- (<span class="string">"empty"</span> meaning that all book columns are <span class="constant">NULL</span>)
</span>author LEFT OUTER JOIN book ON author.id = book.author_id
</code></pre><h3 id="SEMI_JOIN">SEMI JOIN</h3><p>这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。“ SEMI ”在拉丁文中是“半”的意思。这种连接方式是只连接目标表的一部分。这是什么意思呢？再想一下关于作者和书名的连接。我们想象一下这样的情况：我们不需要作者 / 书名这样的组合，只是需要那些在书名表中的书的作者信息。那我们就能这么写：</p>
<pre><code>-- <span class="keyword">Using</span> <span class="keyword">IN</span>
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> author.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)

-- <span class="keyword">Using</span> EXISTS
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)
</code></pre><p>尽管没有严格的规定说明你何时应该使用 IN ，何时应该使用 EXISTS ，但是这些事情你还是应该知道的：</p>
<pre><code><span class="bullet">* </span>IN比 EXISTS 的可读性更好
<span class="bullet">* </span>EXISTS 比IN 的表达性更好（更适合复杂的语句）
<span class="bullet">* </span>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）
</code></pre><p>因为使用 INNER JOIN 也能得到书名表中书所对应的作者信息，所以很多初学者机会认为可以通过 DISTINCT 进行去重，然后将 SEMI JOIN 语句写成这样：</p>
<pre><code><span class="comment">-- Find only those authors who also have books</span>
<span class="operator">SELECT <span class="keyword">DISTINCT</span> first_name, last_name
<span class="keyword">FROM</span> author
<span class="keyword">JOIN</span> book <span class="keyword">ON</span> author.<span class="keyword">id</span> = book.author_id</span>
</code></pre><p>这是一种很糟糕的写法，原因如下：</p>
<pre><code><span class="bullet">* </span>SQL 语句性能低下：因为去重操作（ DISTINCT ）需要数据库重复从硬盘中读取数据到内存中。
<span class="bullet">* </span>这么写并非完全正确：尽管也许现在这么写不会出现问题，但是随着 SQL 语句变得越来越复杂，你想要去重得到正确的结果就变得十分困难。
</code></pre><p>更多的关于滥用 DISTINCT 的危害可以参考这篇博文</p>
<p>（<a href="http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/" target="_blank" rel="external">http://blog.jooq.org/2013/07/30/10-common-mistakes-java-developers-make-when-writing-sql/</a>）。</p>
<h3 id="ANTI_JOIN">ANTI JOIN</h3><p>这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接。举个例子来说，我们列出书名表里没有书的作者：</p>
<pre><code>-- <span class="keyword">Using</span> <span class="keyword">IN</span>
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> author.id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)

-- <span class="keyword">Using</span> EXISTS
<span class="keyword">FROM</span> author
<span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)
</code></pre><p>关于性能、可读性、表达性等特性也完全可以参考 SEMI JOIN。</p>
<p>这篇博文介绍了在使用 NOT IN 时遇到 NULL 应该怎么办，因为有一点背离本篇主题，就不详细介绍，有兴趣的同学可以读一下</p>
<p>（<a href="http://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/" target="_blank" rel="external">http://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/</a>）。</p>
<h3 id="CROSS_JOIN">CROSS JOIN</h3><p>这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法。在实际的应用中，很少有地方能用到 CROSS JOIN，但是一旦用上了，你就可以用这样的 SQL语句表达：</p>
<pre><code>-- Combine <span class="keyword">every</span> author with <span class="keyword">every</span> book
author CROSS <span class="keyword">JOIN</span> book
</code></pre><h3 id="DIVISION">DIVISION</h3><p>DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来，介于这是一个新手指南，解释 DIVISION 已经超出了我们的目的。但是有兴趣的同学还是可以来看看这三篇文章</p>
<p>（<a href="http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/" target="_blank" rel="external">http://blog.jooq.org/2012/03/30/advanced-sql-relational-division-in-jooq/</a>）</p>
<p>（<a href="http://en.wikipedia.org/wiki/Relational_algebra#Division" target="_blank" rel="external">http://en.wikipedia.org/wiki/Relational_algebra#Division</a>）</p>
<p>（<a href="https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/" target="_blank" rel="external">https://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a>）。</p>
<p>推荐阅读 →_→ <a href="http://blog.jobbole.com/40443/" target="_blank" rel="external">《画图解释SQL联合语句》</a></p>
<h3 id="我们学到了什么？-2">我们学到了什么？</h3><p>学到了很多！让我们在脑海中再回想一下。 SQL 是对表的引用， JOIN 则是一种引用表的复杂方式。但是 SQL 语言的表达方式和实际我们所需要的逻辑关系之间是有区别的，并非所有的逻辑关系都能找到对应的 JOIN 操作，所以这就要我们在平时多积累和学习关系逻辑，这样你就能在以后编写 SQL 语句中选择适当的 JOIN 操作了。</p>
<h1 id="7-SQL_中如同变量的派生表">7.SQL 中如同变量的派生表</h1><p>在这之前，我们学习到过 SQL 是一种声明性的语言，并且 SQL 语句中不能包含变量。但是你能写出类似于变量的语句，这些就叫做派生表：</p>
<p>说白了，所谓的派生表就是在括号之中的子查询：</p>
<pre><code>-- A derived table
<span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author)
</code></pre><p>需要注意的是有些时候我们可以给派生表定义一个相关名（即我们所说的别名）。</p>
<pre><code>-- A derived table <span class="keyword">with</span> an <span class="keyword">alias</span>
<span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author) a
</code></pre><p>派生表可以有效的避免由于 SQL 逻辑而产生的问题。举例来说：如果你想重用一个用 SELECT 和 WHERE 语句查询出的结果，这样写就可以（以 Oracle 为例）：</p>
<pre><code>-- <span class="keyword">Get</span> authors<span class="comment">' first and last names, and their age in days</span>
<span class="keyword">SELECT</span> first_name, last_name, age
<span class="keyword">FROM</span> (
  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age
  <span class="keyword">FROM</span> author
)
-- <span class="keyword">If</span> the age <span class="keyword">is</span> greater than <span class="number">10000</span> days
<span class="keyword">WHERE</span> age &gt; <span class="number">10000</span>
</code></pre><p>需要我们注意的是：在有些数据库，以及 SQL ： 1990 标准中，派生表被归为下一级——通用表语句（ common table experssion）。这就允许你在一个 SELECT 语句中对派生表多次重用。上面的例子就（几乎）等价于下面的语句：</p>
<pre><code><span class="keyword">WITH</span> a <span class="keyword">AS</span> (
  <span class="keyword">SELECT</span> first_name, last_name, current_date - date_of_birth age
  <span class="keyword">FROM</span> author
)
<span class="keyword">SELECT</span> *
<span class="keyword">FROM</span> a
<span class="keyword">WHERE</span> age &gt; <span class="number">10000</span>
</code></pre><p>当然了，你也可以给“ a ”创建一个单独的视图，这样你就可以在更广泛的范围内重用这个派生表了。更多信息可以阅读下面的文章（<a href="http://en.wikipedia.org/wiki/View_%28SQL%29" target="_blank" rel="external">http://en.wikipedia.org/wiki/View_%28SQL%29</a>）。</p>
<h3 id="我们学到了什么？-3">我们学到了什么？</h3><p>我们反复强调，大体上来说 SQL 语句就是对表的引用，而并非对字段的引用。要好好利用这一点，不要害怕使用派生表或者其他更复杂的语句。</p>
<h1 id="8-SQL_语句中_GROUP_BY_是对表的引用进行的操作">8.SQL 语句中 GROUP BY 是对表的引用进行的操作</h1><p>让我们再回想一下之前的 FROM 语句：</p>
<pre><code>FROM <span class="tag">a</span>, b
</code></pre><p>现在，我们将 GROUP BY 应用到上面的语句中：</p>
<pre><code>GROUP BY A<span class="class">.x</span>, A<span class="class">.y</span>, B.z
</code></pre><p>上面语句的结果就是产生出了一个包含三个字段的新的表的引用。我们来仔细理解一下这句话：当你应用 GROUP BY 的时候， SELECT 后没有使用聚合函数的列，都要出现在 GROUP BY 后面。</p>
<p>需要注意的是：其他字段能够使用聚合函数：</p>
<pre><code>SELECT A<span class="class">.x</span>, A<span class="class">.y</span>, <span class="function"><span class="title">SUM</span><span class="params">(A.z)</span></span>
FROM A
GROUP BY A<span class="class">.x</span>, A.y
</code></pre><p>还有一点值得留意的是： MySQL 并不坚持这个标准，这的确是令人很困惑的地方。但是不要被 MySQL 所迷惑。 GROUP BY 改变了对表引用的方式。你可以像这样既在 SELECT 中引用某一字段，也在 GROUP BY 中对其进行分组。</p>
<h3 id="我们学到了什么？-4">我们学到了什么？</h3><p>GROUP BY，再次强调一次，是在表的引用上进行了操作，将其转换为一种新的引用方式。</p>
<h1 id="9-SQL_语句中的_SELECT_实质上是对关系的映射">9.SQL 语句中的 SELECT 实质上是对关系的映射</h1><p>我个人比较喜欢“映射”这个词，尤其是把它用在关系代数上。一旦你建立起来了表的引用，经过修改、变形，你能够一步一步的将其映射到另一个模型中。 SELECT 语句就像一个“投影仪”，我们可以将其理解成一个将源表中的数据按照一定的逻辑转换成目标表数据的函数。</p>
<p>通过 SELECT语句，你能对每一个字段进行操作，通过复杂的表达式生成所需要的数据。</p>
<p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条：</p>
<pre><code><span class="number">1.</span> 你仅能够使用那些能通过表引用而得来的字段；
<span class="number">2.</span> 如果你有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句，你只能够使用 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句后面的字段或者聚合函数；
<span class="number">3.</span> 当你的语句中没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 的时候，可以使用开窗函数代替聚合函数；
<span class="number">4.</span> 当你的语句中没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 的时候，你不能同时使用聚合函数和其它函数；
<span class="number">5.</span> 有一些方法可以将普通函数封装在聚合函数中；
<span class="number">6.</span> ……
</code></pre><p>一些更复杂的规则多到足够写出另一篇文章了。比如：为何你不能在一个没有 GROUP BY 的 SELECT 语句中同时使用普通函数和聚合函数？（上面的第 4 条）</p>
<p>原因如下：</p>
<pre><code><span class="number">1</span>. 凭直觉，这种做法从逻辑上就讲不通。
<span class="number">2</span>. 如果直觉不能够说服你，那么语法肯定能。 SQL : <span class="number">1999</span> 标准引入了 GROUPING SETS，SQL： <span class="number">2003</span> 标准引入了 <span class="keyword">group</span> sets : <span class="keyword">GROUP</span> <span class="keyword">BY</span>() 。无论什么时候，只要你的语句中出现了聚合函数，而且并没有明确的 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 语句，这时一个不明确的、空的 GROUPING <span class="keyword">SET</span> 就会被应用到这段 SQL 中。因此，原始的逻辑顺序的规则就被打破了，映射（即 <span class="keyword">SELECT</span> ）关系首先会影响到逻辑关系，其次就是语法关系。（译者注：这段话原文就比较艰涩，可以简单理解如下：在既有聚合函数又有普通函数的 SQL 语句中，如果没有 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 进行分组，SQL 语句默认视整张表为一个分组，当聚合函数对某一字段进行聚合统计的时候，引用的表中的每一条 <span class="keyword">record</span> 就失去了意义，全部的数据都聚合为一个统计值，你此时对每一条 <span class="keyword">record</span> 使用其它函数是没有意义的）。
</code></pre><p>糊涂了？是的，我也是。我们再回过头来看点浅显的东西吧。</p>
<h3 id="我们学到了什么？-5">我们学到了什么？</h3><p>SELECT 语句可能是 SQL 语句中最难的部分了，尽管他看上去很简单。其他语句的作用其实就是对表的不同形式的引用。而 SELECT 语句则把这些引用整合在了一起，通过逻辑规则将源表映射到目标表，而且这个过程是可逆的，我们可以清楚的知道目标表的数据是怎么来的。</p>
<p>想要学习好 SQL 语言，就要在使用 SELECT 语句之前弄懂其他的语句，虽然 SELECT 是语法结构中的第一个关键词，但它应该是我们最后一个掌握的。</p>
<h1 id="10-SQL_语句中的几个简单的关键词：DISTINCT，UNION，ORDER_BY_和_OFFSET">10.SQL 语句中的几个简单的关键词：DISTINCT，UNION，ORDER BY 和 OFFSET</h1><p>在学习完复杂的 SELECT 豫剧之后，我们再来看点简单的东西：</p>
<pre><code>* 集合运算（ <span class="keyword">DISTINCT</span> 和 <span class="keyword">UNION</span> ）
* 排序运算（ <span class="keyword">ORDER</span> <span class="keyword">BY</span>，OFFSET…FETCH）
</code></pre><h3 id="集合运算（_set_operation）：">集合运算（ set operation）：</h3><p>集合运算主要操作在于集合上，事实上指的就是对表的一种操作。从概念上来说，他们很好理解：</p>
<pre><code><span class="bullet">* </span>DISTINCT 在映射之后对数据进行去重
<span class="bullet">* </span>UNION 将两个子查询拼接起来并去重
<span class="bullet">* </span>UNION ALL 将两个子查询拼接起来但不去重
<span class="bullet">* </span>EXCEPT 将第二个字查询中的结果从第一个子查询中去掉
<span class="bullet">* </span>INTERSECT 保留两个子查询中都有的结果并去重
</code></pre><h3 id="排序运算（_ordering_operation）：">排序运算（ ordering operation）：</h3><p>排序运算跟逻辑关系无关。这是一个 SQL 特有的功能。排序运算不仅在 SQL 语句的最后，而且在 SQL 语句运行的过程中也是最后执行的。使用 ORDER BY 和 OFFSET…FETCH 是保证数据能够按照顺序排列的最有效的方式。其他所有的排序方式都有一定随机性，尽管它们得到的排序结果是可重现的。</p>
<p>OFFSET…SET是一个没有统一确定语法的语句，不同的数据库有不同的表达方式，如 MySQL 和 PostgreSQL 的 LIMIT…OFFSET、SQL Server 和 Sybase 的 TOP…START AT 等。具体关于 OFFSET..FETCH 的不同语法可以参考这篇文章<br>（<a href="http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/" target="_blank" rel="external">http://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/</a>）。</p>
<p>让我们在工作中尽情的使用 SQL！</p>
<p>正如其他语言一样，想要学好 SQL 语言就要大量的练习。上面的 10 个简单的步骤能够帮助你对你每天所写的 SQL 语句有更好的理解。另一方面来讲，从平时常见的错误中也能积累到很多经验。</p>
<p>基本参考<a href="http://blog.jobbole.com/55086/" target="_blank" rel="external">十步完全理解SQL</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-SQL_一种声明式语言">1.SQL 一种声明式语言</h1><p>SQL是一种声“明式”语言。SQL语言是为计算机声明了一个你想从数据库中获得结果的范例（可以理解为SQL语句），而不是告诉计算机如何得到SQL查询的结果。</p>
<p>如果SQL语言这么简单]]>
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <link href="http://yoursite.com/2015/09/12/hello-world/"/>
    <id>http://yoursite.com/2015/09/12/hello-world/</id>
    <published>2015-09-12T15:55:08.000Z</published>
    <updated>2015-09-12T15:55:08.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to My Notes! This is my very first post. 开始写博客了，一直以来想把自己的学习的东西记录下来，可能比较懒吧，最近才开始有了真实的行动来完成。</p>
<h2 id="构建博客的框架">构建博客的框架</h2><pre><code>结构采用比较流行的 hexo，之所以选择他是因为他方便、快。
博客主题采用的是当前星最高的也是我比较喜欢的主题 <span class="keyword">next</span>。
</code></pre><h2 id="博客的主要内容">博客的主要内容</h2><pre><code>主要记录自己在工作学习中用的知识点，以备平时需要时查询，也希望大家来交流下经验。
</code></pre><h2 id="后记">后记</h2><pre><code>比自己聪明的人还在努力的学习，我有什么资格来放弃学习！
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to My Notes! This is my very first post. 开始写博客了，一直以来想把自己的学习的东西记录下来，可能比较懒吧，最近才开始有了真实的行动来完成。</p>
<h2 id="构建博客的框架">构建博客的框架</h2><pre>]]>
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
